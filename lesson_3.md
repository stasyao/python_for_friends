# Урок 3. Подробнее об оформлении строк. Встроенные функции. Параметры и аргументы

В этом уроке мы продолжим работать с интерпретатором в интерактивном режиме, а в конце напишем программу в отдельном `py`-файле и запустим ее.

Поскольку нам понадобится работать с текстом (т.е. объектом класса `str`), сначала поговорим подробнее об их оформлении.

## Оформление объектов текста (строк)

Из урока 1 вы помните, что объекты строк могут создаваться в виде литерала. В этом случае мы просто берем текст, который хотим использовать в нашей программе и окружаем его одинарными или двойными кавычками-"лапками". Такое оформление позволяет отделить объекты строк от *имен* переменных, классов, функций.

Пример &mdash; `'Это какой-то текст'`.

Важно уяснить: окружающие текст кавычки-лапки **не являются его частью**.

Но что если нам в самом тексте нужно использовать кавычки такого же вида? Как интерпретатор поймет, 
где кавычка как часть текста, а где служебная кавычка?

Есть 2 варианта.

Вариант 1. Если сам текст в любой своей части содержит кавычки-лапки, они **должны отличаться** от служебных кавычек-лапок, которые стоят перед началом и после окончания текста.

Например, текст *"Михал Светлов" - название теплохода* содержит в себе **двойные кавычки-лапки**. 
Чтобы этот текст использовать как объект класса строк в коде, его нужно окружить **одинарными кавычками-лапками**. Получится так: `'"Михаил Светлов" - название теплохода'`. Обратите внимание: впереди одинарная служебная кавычка, а за ней идет двойная, являющаяся частью текста. После окончания текста идет одинарная служебная кавычка. 

Пробуем. Введите в интерпретаторе

```py
>>> '"Михаил Светлов" - название теплохода'
'"Михаил Светлов" - название теплохода'
```

Интерпретатор всё правильно понял, перед ним строковый объект.

Вариант 2. Кавычки, являющиеся частью текста и совпадающие по начертанию со служебными кавычками, нужно *экранировать*. "Экранировать" означает поставить перед кавычкой символ `\` (обратная косая черта, бекслеш, backslash). Сам бекслеш **не войдет** в текст, но даст понять интерпретатору, что перед ним "обычная", а не служебная кавычка.

Например, текст `"Михаил Светлов" - название теплохода`, чтобы создать из него строковый объект, можно окружить двойными служебными кавычками. Но тогда двойные кавычки в своем тексте надо экранировать &mdash; `\"Михаил Светлов\"`.

Пробуем. Введите в интерпретаторе `"\"Михаил Светлов\" - название теплохода"`.

```py
>>> "\"Михаил Светлов\" - название теплохода"
'"Михаил Светлов" - название теплохода'
```

Если ни один из вариантов не соблюсти, интерпретатор выдаст ошибку.

Пробуем

```
>>> ""Михаил Светлов" - название теплохода"
SyntaxError: invalid syntax # Кавычки в тексте повторяют служебные кавычки, но не экранированы
```

**Запоминаем**: кавычки-лапки мы не включаем в состав текста, а окружаем его ими, тем самым создавая в коде объект класса строк. Эти служебные кавычки по своему виду не должны совпадать по начертанию **ни с одной из кавычек**, входящих в состав текста. Второй вариант: кавычки, являющиеся частью текста, должны быть *экранированы* с помощью символа `\`. Экранирование &mdash; это способ сказать интерпретатору, что тот или иной символ не имеет служебного назначения, а является лишь частью текста.

## Функции

Функции &mdash; это специальные объекты, которые внутри себя содержат набор готового Python-кода, который будет *исполнен* при *вызове* функции.

У функций есть ряд общих черт с классами:
- как и классы, функции могут быть встроенными (т.е. уже существующими в интерпретаторе, нам остается только ими пользоваться) и созданными нами собственноручно;
- как и у классов, у функций есть собственные имена (правда, бывают анонимные функции, но пока мы их касаться не будем);
- как и классы, функции можно вызвать. Вызов класса порождает создание объекта класса, вызов функции порождает исполнение кода, содержащегося в ней.

В терминологии типов синтаксических конструкций:
- создание функции &mdash; это инструкция (statement)
- вызов функции &mdash; это выражение (expression)

Схематично выражение вызова функции выглядит так: `имя_функции()`. Внутри круглых скобок могут быть *аргументы*, о них мы поговорим чуть ниже.

**Запоминаем**: функции &mdash; это именованные объекты, которые содержат готовый к исполнению код. Этот код исполняется при вызове функции. Вызов функции обозначается круглыми скобками, приставленными к имени функции.

## Функции всегда что-то возвращают, включая "ничто"

В результате вызова функции могут происходить какие-то действия (например, будет создан новый файл, будет скачана интернет-страница, будет произведено какое-то вычисление с отображением результата в терминале и т.д.) и, в любом случае, будет *возвращен* какой-то объект.

*Возвратить* означает "предоставить какой-то объект для дальнейшего использования в программе".

Есть 2 типа объектов, которые возвращает функция:

- специальный объект под именем `None`. Буквально означает "ничто". Да-да, функция может вернуть "ничто". В этом случае можно сказать "такая-то функция ничего не возвращает". Но нужно понимать, что за этой фразой стоит "такая-то функция возвращает объект None". Сама суть этого объекта продемонстрировать, как-то обозначить, что ничего иного функция не возвращает.

- любой иной объект кроме `None`. Строка, число, более сложный объект &mdash; всё что угодно. Эти объекты мы можем дальше использовать в нашей программе.

Простой пример. Представим себе функцию, которой мы передаем 2 числа, а внутри функции код, при исполнении которого эти два числа перемножаются и возвращается результат произведения. Соответственно мы можем *вызвать* функцию, она будет исполнена и вернет нам новый объект &mdash; результат произведения. Этот объект мы можем дальше использовать в нашей программе.

**Запоминаем**: функция помимо совершения каких-то иных полезных действий всегда возвращает какой-то объект. Это может быть специальный объект `None`, что означает "функция не вернула какой-либо полезный для дальнейшего использования объект", или любой другой объект. Грубо говоря, функция возвращает или "бесполезный" `None` или какой-то "полезный" объект.

Возврат функцией объекта `None` совершенно не означает, что она бесполезная. Возвращение какого-либо объекта (включая `None`) &mdash; лишь часть работы функции.

## Встроенные функции

Мы уже знаем три встроенных класса. Их имена `int`, `float`, `str`. Помимо встроенных классов у интерпретатора есть встроенные функции. Их он тоже знает по именам.

Что делает конкретная встроенная функция описано в документации. Здесь я расскажу то же самое, только по возможности более простыми словами.

В этом уроке мы познакомимся с одной встроенной функцией. Ее имя `print`. Давайте проверим, что интерпретатору знакомо это имя. Наберите `print` и нажмите Enter.

```py
>>> print
<built-in function print>
```

Интерпретатор ответил, что знает эти имена, за ними скрываются встроенные (built-in) функции.

## Встроенная функция `print`

Назначение этой функции &mdash; отобразить в терминале *строковое представление* одного или нескольких объектов. 

Если объектов несколько, то функция `print` выводит в одну линию сначала строковое представление первого объекта, затем ставит пробел, затем представление второго объекта, затем пробел и т.д.

Пробел &mdash; разделитель по умолчанию, можно задать любой другой символ в качестве разделителя, как это сделать, мы увидим чуть позже.

Зачем нужна рассматриваемая функция? Чтобы показать в терминале какие-то промежуточные или окончательные результаты исполнения программы, если в этом есть необходимость. Отобразить какую-то информацию, которая необходима пользователю программы, взаимодействующему с ней через командную строку.

Не пугайтесь этого мудреного словосочетания *строковое представление*. Это не что иное как текстовое описание того, что представляет из себя объект.

Представьте, что вы смотрите на кота Барсика. Уши, лапы, хвост, сложный такой объект. А теперь вам нужно представить этот объект в виде какого-то *описания*, в виде текста. Вот этим занимается функция `print` &mdash; она отобразит в терминале текстовое описание объекта, например, `Кот Барсик 2023 года рождения` или очень по-машинному `Барсик, экземпляр класса Кот` или ещё каким-то текстом, содержание которого определяется методом объекта, отвечающим как раз за то, какими словами он должен быть описан.

Иными словами, функция `print` выводит в терминал текст с описанием объекта.

Для простейших объектов &mdash; чисел и строк &mdash; текстовое описание предельно ясное &mdash; оно просто состоит из тех же символов, что составляют значение этих объектов.

Строковое представление объекта числа 2 &mdash; текст из одного символа 2.

Строковое представление объекта строки &mdash; понятное дело, весь текст, заключенный в этот объект.

Пробуем в интерпретаторе вызвать функцию `print` (для вызова используем круглые скобки) с простейшими объектами.

```py
>>> print(2)
2
>>> print('Какой-то текст')
Какой-то текст
```

Возьмем пример посложнее. Возьмем не какой-то экземпляр класса строк или чисел, а сам класс. Например, класс `int`. Класс сам по себе &mdash; это самостоятельный объект.

Вот такая задача: вывести в терминал *строковое представление* класса `int`. Иными словами, показать текстовое описание данного объекта.

Пробуем

```py
>>> print(int)
<class 'int'>
>>>
```

Видим, что те, кто разрабатывал класс `int`, заложили в метод, который отвечает за строковое представление этого класса, вот такой текст: `<class 'int'>`. Напомню, это просто текст, который призван дать понимание, что за объект мы показываем в терминале.

Помните, когда мы разбирали оператор `+`, мы говорили, что по сути за ним стоит вызов метода `__add__`, который есть у объектов чисел?

Так вот у любого объекта &mdash; у самого класса и у любого его экземпляра есть метод `__str__`. Этот метод отвечает текстовое описание (*строковое представление*) объекта.

Функция `print` занимается тем, что у переданных ей объектов вызывает метод `__str__` и показывает в терминале, какой текст эти методы вернули.

**Запоминаем**: встроенная функция `print` отображает в терминале текстовое описание объектов. Текстовое описание простейших объектов &mdash; чисел и строк &mdash; ничем не отличается от их буквального написания, поэтому `print(2)` выведет в терминал текст `2`.

## Сигнатура функции `print`

У любой функции есть *сигнатура* (signature). Сигнатура &mdash; это набор характеристик функции или метода.

Сигнатура включает в себя:
1. Имя функции
2. Список параметров функции и типы параметров
3. Что именно возвращает функция

Рассмотрим сигнатуру функции `print` согласно [документации](https://docs.python.org/3/library/functions.html#print) и пошагово ее разберем, это не страшно.

```py
print(*objects, sep=' ', end='\n', file=None, flush=False)
```

1. Имя функции &mdash; `print`

2. Параметры функции:
- `*objects`
- `sep`
- `end`
- `file`
- `flush`

3. Функция возвращает `None`.

Теперь подробнее о самом сложном и интересном &mdash; о параметрах.

Параметры &mdash; это имена в объявлении функции, которые обозначают, что при *вызове* функции на местах этих имен должны (или могут) находиться конкретные объекты, необходимые для правильной работы функции. Эти *конкретные объекты* передаваемые на место тех или иных параметров, называются *аргументами*.

Есть целая типология параметров и аргументов, будем их разбирать постепенно на примере конкретных функций, а не абстрактно.

Пока разберем типы параметров, которые есть у функции `print`.

**Запоминаем**: функции для работы могут понадобиться какие-то объекты. Например, если функция выполняет перемножение любых двух чисел, то для корректной работы ей понадобится *передать* объекты этих чисел. Количество объектов, которые *ожидает на вход* (т.е. при вызове) функция, и очередность их передачи описываются с помощью специальных имен &mdash; *параметров*. Какое назначение у того или иного параметра, описывается в документации на функцию. Объекты, передаваемые для параметров, называются *аргументами*.

### Параметр `*objects`

Как я уже сказал, у каждого параметра есть имя. Имена параметрам придумывают разработчики функции. Когда мы будем писать собственные функции, мы тоже будем это делать.

В данном случае разработчики функции `print` ее первый параметр назвали `*objects` ("объекты", подразумеваются объекты, чье текстовое описание мы хотим вывести в терминал).

Звёздочка `*` в названии параметра означает, что перед нами `var-positional parameter` или по-русски "позиционный параметр переменной длины".

"Переменной длины", то есть для этого параметра можно передать в качестве аргумента *любое число объектов или вообще ни одного*.

"Позиционный" означает 3 вещи:
1. При передаче аргумента мы не можем сопровождать его именем параметра (формат `имя_параметра=аргумент` **недопустимо**). Скоро увидите пример, который прояснит эту мысль
2. Аргумент должен быть расположен именно на той позиции, на которой в сигнатуре функции находится соответствующий этому аргументу параметр. Иными словами, вот стоит `*objects` первым в списке параметров, значит, аргумент (аргументы) для этого параметра должны идти первыми.
3. В случае, если позиционный параметр является ещё и параметром переменной длины, то он **всегда** должен располагаться первым в сигнатуре.

Запустите (если закрыли) интерпретатор в интерактивном режиме, будем закреплять на примерах.

Как мы выяснили по сигнатуре функции `print`, ее `*objects`:
- расположен первым
- позиционный
- принимает один или несколько аргументов, т.е. конкретных объектов, которыми будет оперировать функция

*Вызываем* функцию `print` с *одним аргументом* &mdash; объектом числа 2.

```py
>>> print(2)
2
```

Сравните:
- сигнатура &mdash; `print(*objects, sep=' ', end='\n', file=None, flush=False)`
- вызов &mdash; `print(2)`

Вопрос: к какому параметру функции `print` относится переданный при ее вызове аргумент `2`?

Ответ: исходя из того, что на первом месте среди параметров находится параметр `*objects` и он является позиционным, аргумент `2` относится именно к этому параметру.

Вопрос: можем ли мы передать аргумент `2` вместе с именем параметра, т.е. в формате `print(*objects=2)`?

Ответ: нет, это будет ошибкой, т.к. аргументы для *позиционных параметров переменной длины* никогда не могут быть переданы в качестве именованных аргументов (т.е. в сопровождении имени параметра).

Пробуем ошибиться

```py
>>> print(*objects=2)
  File "<stdin>", line 1
    print(*objects=2)
                     ^
SyntaxError: invalid syntax
```

Следующий момент: мы уже упомянули, что `*` символизирует неопределенное число аргументов для данного параметра. В этом случае, если аргументов для данного параметра несколько, они просто перечисляются через запятую.

Пример

```py
>>> print(2, 'Барсик', 5, 10)
2 Барсик 5 10
```

Объект числа `2`, текст (объект строк) `'Барсик'`, объект числа 5, объект числа 10 &mdash; все эти 4 объекта являются аргументами для параметра `*objects` функции `print`.

Аргументы, которые передаются для `var-positional`-параметров, считаются **позиционными аргументами**. Позиционные аргументы **всегда** передаются при вызове функции **без** имени параметра, к которому аргумент относится. Функция сама свяжет аргумент с соответствующим ему параметром исходя из очередности расположения (например, первый аргумент при вызове функции будет связан с первым параметром в ее сигнатуре).

Перейдем к следующему параметру в сигнатуре функции `print` &mdash; параметру `sep`.

### Параметр `sep`

Параметры вида `имя_параметра` и `имя_параметра=значение` называются "позиционными-или-именованными" параметрами (`positional-or-keyword`).

Взглянем ещё раз на сигнатуру функции `print`

```py
print(*objects, sep=' ', end='\n', file=None, flush=False)
```

Видим, что параметр `sep` соответствует формату `имя_параметра=значение`, то есть по своему типу является "позиционным-или-именованным".

Особенности "позиционных-или-именованных" параметров в том, что аргументы для этих параметров можно по общему правилу передать в двух форматах:

1. Аргумент без имени параметра, тогда параметр будет считаться позиционным, а значит аргумент надо расположить именно на том месте по порядку следования параметров, на котором параметр находится в сигнатуре.

Аргумент, который передается для позиционного параметра, считается **позиционным аргументом**.

2. Аргумент с именем параметра в формате `имя_параметра=аргумент`. Такой аргумент называется **именованным аргументом** (keyword argument).

Поскольку именованный аргумент содержит имя параметра, то жесткая привязка к позиции параметра среди других, уже не требуется. Поэтому именованный аргумент можно расположить на любом месте при вызове функции, но **строго после всех позиционных аргументов**.

Скоро проиллюстрирую на примерах эти вещи, а пока ещё одна важная особенность: если первым параметром в сигнатуре является позиционный параметр переменной длины (var-positional parameter), то аргументы для "позиционных-или-именованных" параметров нужно передавать **только** в формате именованных.

А теперь примеры.

Смотрим на сигнатуру: `print(*objects, sep=' ', end='\n', file=None, flush=False)`

Теперь делаем вызов функции `print` в таком формате:

```py
>>> print(2, 10)
2 10
```

Вопрос: аргументы 2 и 10 к каким параметрам относятся?

Ответ: все относятся к одному параметру &mdash; позиционному параметру переменной длины `*objects`.

Мы видим, что сколько бы аргументов мы не перечислили в начале вызова функции, хоть один, хоть двести, их все "запылесосит" `*objects`. Длина у него неопределенная.

Этим и объясняется, почему все следующие параметры мы должны использовать исключительно как именованные, даже если они допускают позиционный формат. Только явно указав имя следующего параметра, например, `sep`, мы остановим сбор аргументов для `*objects` и скажем интерпретатору "а вот этот аргумент идет для параметра `sep`.

Проверим, передадим именованный аргумент для параметра `sep` в виде строки с символом `|` (т.е. `'|'`).

```py
>>> print(2, 10, sep='|')
2|10
```

Работа этого кода дает понять, за что отвечает параметр `sep` (сокращение от слова "separator" &mdash; "разделитель"). Через параметр `sep` мы определяем, какими символами мы будем разделять между собой строковые представления объектов, переданных в `*objects`.

В данном случае мы между выводом `2` и `10` поставили вертикальную черту `|`. По умолчанию же был бы пробел (посмотрите ещё раз на параметр `sep` в сигнатуре &mdash; `sep='|'`).

Если в сигнатуре функции после имени параметра стоит `=` и указан какой-то объект, значит, **этот объект будет использоваться в качестве аргумента по умолчанию, если для данного параметра не будет передан какой-либо другой объект-аргумент**.

Давайте сделаем ещё один вызов `print`, аналогичный предыдущему, но без указания имени параметра `sep`. Думаю, вы уже понимаете, что произойдёт, но давайте закрепим.

```py
>>> print(2, 10, '|')
2 10 |
>>>
```

Строка с вертикальной чертой была включена в состав аргументов для `*objects` и соответственно никак на параметр `sep` не повлияла. Мы получили три выведенных подряд строки &mdash; 2, 10 и |, а их между собой разделил пробел &mdash; *дефолтный* аргумент параметра `sep`.

Последний пример &mdash; нарушим правило, согласно которому именованные аргументы не должны идти перед позиционными.

```py
>>> print(sep='|', 'текст для вывода в терминал')
  File "<stdin>", line 1
    print(sep='|', 'текст для вывода в терминал')
                                                ^
SyntaxError: positional argument follows keyword argument
>>>
```

Мы решили именованный аргумент `sep='|'` поставить перед позиционным `'текст для вывода в терминал'`. Ожидаемо получили синтаксическую ошибку, причем довольно распространенную на практике: "positional argument follows keyword argument" &mdash; "позиционный аргумент следует за именованным" (а так нельзя).

### Параметры `end`, `file` и `flush`

Вернемся к сигнатуре

```py
print(*objects, sep=' ', end='\n', file=None, flush=False)
```

Сейчас мы не будем рассматривать, за что конкретно отвечают параметры `end`, `file` и `flush`, но мы уже можем классифицировать их по типологии параметров и сказать, как их нужно передавать (ведь все три параметра идентичны по формату параметру `sep`).

Поехали:
- все три параметра являются "позиционными-или-именованными"
- поскольку в начале сигнатуры указан позиционный параметр переменной длины `*objects`, то для всех трех параметров нужно передавать исключительно *именованные аргументы*, т.е. аргументы в сопровождении имен параметров, к которым эти аргументы относятся
- именованные аргументы для всех трех параметров должны передаваться после позиционных аргументов для `*objects`
- между собой именованные аргументы для рассматриваемых параметров можно расположить в любом порядке, например:
  - `print('какой-то текст', sep='|', end='\n')`
  - `print('какой-то текст', end='\n', sep='|')`
  - `print('какой-то текст', file=None, sep=' ', flush=True, end=' ')`
- у всех трех параметров есть *дефолтные аргументы* (`'\n'`, `None`, `False`), которые будут использованы, если других аргументов передано не будет.

### Параметры функции `print`: итог

Согласно сигнатуре функции `print`, у нее 5 параметров:
- `*objects` &mdash; позиционный параметр переменной длины, а значит для него можно передать неопределенное число аргументов. Согласно документации аргументы для этого параметра &mdash; это те объекты, чье строковое представление мы хотим вывести в терминал
- `sep=' '`, `end='\n'`, `file=None`, `flush=False` &mdash; "позиционные-или-именованные" параметры с дефолтными аргументами. Собственные аргументы можем передать только в виде именованных (т.е. в формате `имя_параметра=аргумент`), т.к. впереди стоит позиционный параметр переменной длины.

### Что возвращает функция `print`

Это последнее, что нам нужно узнать о данной функции. Функция `print` возвращает `None`, что равносильно "ничего не возвращает".

Это хороший пример "ничего не возвращающей" функции. Никаких "полезных" объектов для дальнейшего использования в нашем коде она не создает. Её задача в одном &mdash; совершить полезное действие в виде отображение информации в терминале.

## Пишем программу

Напишем короткую программу, которая обобщит пройденный нами за три урока материал.

Вот построчное описание кода программы:

1. Создать любое целое число и "привязать" его к переменной с именем `left_number`.
2. Создать еще одно целое число и "привязать" его к переменной с именем `right_number`.
3. Сложить оба числа, результат "привязать" к переменной с именем `result`.
4. Вывести в терминал текст следующего вида: `Мы сложили число <левое_число> с числом <правое_число> и получили число <результат>`, где:
- `<левое_число>` &mdash; число из переменной `left_number`
- `<правое_число>` &mdash; число из переменной `right_number`
- `<результат>` &mdash; число из переменной `result`.

Пример вывода в терминал после запуска файла с программой:

```
Мы сложили число 5 с числом 6 и получили число 11`.
```

Откройте директорию `programming` с помощью `VS Code`. Создайте в ней файл с именем `01_print_sum.py`. В этом файле напишите код из 4 строк согласно приведенному выше описанию.

Напомню, если кто-то пропустил гайд по установке Python-интерпретатора, `programming` &mdash; это обычная папка на рабочем столе, которую мы создали сами и в которой будем хранить код наших программ.

Попробуйте сначала самостоятельно. Вне зависимости от результата ниже будет подробный разбор этой программы.

## Разбор программы

Пойдем построчно

1. Создать любое целое число и "привязать" его к переменной с именем `left_number`.

```py
left_number = 25
```

Объявляем в левой части инструкции имя `left_number` и с помощью оператора присваивания `=` привязываем к этому имени объект класса целых чисел `int` со значением 25 (создание объекта мы оформили в виде литерала).

2. Создать еще одно целое число и "привязать" его к переменной с именем `right_number`.

```py
right_number = 26
```

Суть та же, что и в п. 1

3. Сложить оба числа, результат "привязать" к переменной с именем `result`.

```py
result = left_number + right_number
```

В выражении по сложению ранее созданных объектов чисел мы используем переменные, которые на эти объекты ссылаются. Мы помним, что переменная ведет себя так и только так, как если бы мы использовали стоящий за ней объект непосредственно.

Результат выражения мы привязываем к новой переменной с именем `result`.

4. Вывести в терминал текст следующего вида: `Мы сложили число <левое_число> с числом <правое_число> и получили число <результат>`, где:
- `<левое_число>` &mdash; число из переменной `left_number`
- `<правое_число>` &mdash; число из переменной `right_number`
- `<результат>` &mdash; число из переменной `result`.

Тут самое интересное и сложное.

Давайте разбираться. "Вывести в терминал...". Какой инструмент для этого подойдет? Знаем такой инструмент, встроенная функция `print`.

Что она должна вывести в терминал? Строку вида

`Мы сложили число <левое_число> с числом <правое_число> и получили число <результат>`

Так. Может быть нам достаточно, тогда в качестве аргумента передать один строковый объект, например так:

```py
print('Мы сложили число <левое_число> с числом <правое_число> и получили число <результат>')
```

Нет, такой вариант нам не подходит, у нас `<левое_число>`, `<правое_число>` и `<результат>` &mdash; это ранее созданные объекты чисел и результата их сложения.

Хм... Ну давай просто укажем эти числа внутри строки, которую мы будем передавать аргументов в `print`?

```py
print('Мы сложили число 25 с числом 26 и получили число 51')
```

Нет, не вариант:
- сегодня мы используем числа 25 и 26, а завтра мы поменяли в коде значения переменных, например, на 5 и 10. Придется лезть еще и в вызов функции `print` и там менять числа. Больше изменений &mdash; больше вероятность ошибки
- главное &mdash; а какой смысл нам было писать выражение на вычисление суммы двух чисел, если в итоге мы должны сами в уме его вычислить и вписать в строку для вывода в терминал? Что-то не ощущается никакой автоматизации...

Значит, в `print` надо передать напрямую переменные `left_number`, `right_number`, `result`, а функция обратится к объектам, стоящим за этими переменными, и выведет в терминал их значение, каким бы оно не было.

Супер. Но давай ещё раз взглянем на шаблон из задачи.

`Мы сложили число <левое_число> с числом <правое_число> и получили число <результат>`

Как сюда вставить переменные, ведь помимо них, справа и слева, есть текст?

Вспоминаем, как по умолчанию работает функция `print`, если для ее параметра `*objects` передали несколько объектов-аргументов:
- она поочередно выведет в терминал строковое представление каждого объекта аргумента
- в качестве разделителя между этими строками будет стоять пробел (дефолтный аргумент для параметра `sep`)

Значит, нам нужно разбить наш шаблон на части и каждую часть как самостоятельный объект передать функции `print`. У нас будут следующие объекты:
- объект строки `'Мы сложили число'`
- объект числа, скрывающийся за переменной с именем `left_number`
- объект строки `'с числом'`
- объект числа, скрывающийся за переменной с именем `right_number`
- объект строки `'и получили число'`
- объект числа, скрывающийся за переменной с именем `result`

Всего будет 6 объектов-аргументов.

Вызов функции `print` будет выглядеть так:

```py
print('Мы сложили число', left_number, 'с числом', right_number, 'и получили число', result)
```

Сначала в терминале появится текст `Мы сложили число` плюс пробел (разделитель, установленный параметром `sep`), затем "текст" числа, которое скрывается за переменной `left_number` (опять же плюс пробел, т.к. разделитель ставится после каждого объекта) и т.д.

Вот так, зная поведение функции `print`, мы смогли решить задачу. Более того, финальный вывод в терминал, благодаря использованию переменных, теперь никак не зависит от конкретного набора чисел.

Полный код программы [здесь](https://github.com/stasyao/python_for_friends/blob/master/programming/01_print_sum.py)

## Домашнее задание

Напишите программу по следующему плану:
1. Объявить переменную и присвоить ей объект целого числа 10
2. Выполнить умножение (оператор `*`) этого числа на число 2
3. Вывести в терминал сообщение в следующем формате

```
<изначально_созданное_число> * 2 = <результат_умножения>
```

где `<изначально_созданное_число>` и `<результат_умножения>` &mdash; строковое представление чисел, которые вы использовали в программе.

Обратите внимание, что числа могут меняться и это не должно влиять на ту часть кода, которая отвечает за вывод в терминал (в этой строке кода ничего не потребуется менять, если вы поменяете число в шаге 1).

## Заключение. Основные тезисы.

1. Экранирование &mdash; это способ сказать интерпретатору, что тот или иной символ не имеет служебного назначения, а является лишь частью текста. Для экранирования используют бекслеш, который ставят перед экранируемым символом. Например, `\"` говорит интерпретатору, что двойная кавычка &mdash; просто двойная кавычка, часть текста, а не служебный символ, обозначающий строковый литерал.

2. Функции &mdash; это специальные объекты, которые внутри себя содержат набор готового Python-кода, который будет *исполнен* при *вызове* функции.

3. Помимо встроенных классов в Python есть набор встроенных функций. У каждой функции, как и у класса, есть свое уникальное имя. Имя функции + круглые скобки означает вызов функции.

4. Функции для корректной работы могут понадобиться один или несколько объектов. Эти объекты *передаются* функции при ее вызове (помещаются внутрь круглых скобок через запятую).

5. Понять, сколько объектов нужно передать и в какой последовательности, помогают *параметры*. Это такие имена, которые служат как бы "ячейками" для помещения в них объектов при вызове функции.

6. Описание функции и ее параметров называется *сигнатурой*. Например, сигнатура функции `print` выглядит так: `print(*objects, sep=' ', end='\n', file=None, flush=False)`, где всё, что перечислено в скобках &mdash; это названия параметров, а после оператора `=` *дефолтные аргументы*, т.е. объекты, которые будут переданы в функцию при ее вызове по умолчанию, если мы не захотим передать что-то свое для конкретного параметра.

7. Есть разные типы параметров, пока мы познакомились с двумя:
- позиционными параметрами переменной длины (обозначаются `*`), например, `*objects`
- "позиционными-или-именованными" параметрами (параметры вида `имя_параметра` и `имя_параметра=значение`), например, `sep=' '`.

От типа параметра зависят две вещи:
- каким по счету должен передаваться аргумент для этого параметра при вызове функции;
- в каком виде можно или следует передать аргумент для этого параметра при вызове функции:
  - в виде *именованного аргумента*, т.е. в формате `имя_параметра=аргумент`
  - в виде *позиционного аргумента*, т.е. только сам объект-аргумент без упоминания имени параметра (функция, опираясь на очередность передачи аргумента сама свяжет его с параметром, который расположен на таком же по счету месте в сигнатуре)

Общее правило: именованные аргументы **никогда** не могут при вызове функции идти **перед** позиционными. Вызов функции в формате `имя_функции(имя_параметра=аргумент1, аргумент2)` недопустим.

8. Все позиционные аргументы, которые передаются в функцию `print`, считаются аргументами для параметра `*objects`. Функция поочередно в одну линию выведет в терминал строковое представление каждого из этих аргументов, поставив между каждым объектом разделитель-пробел. За формат разделителя отвечает параметр `sep`. По умолчанию &mdash; это пробел. При вызове функции можно передать любой другой разделитель для этого параметра, например, `sep='|'`.

9. Все функции *возвращают* один из двух объектов:
- объект `None`, который символизирует, что функция *ничего не возвращает* или, иными словами, *функция вернула ничто*.
- любой иной объект.

Возвращенный функцией объект (кроме `None`) можно дальше использовать по ходу программы.

Функция `print` &mdash; пример функции, которая ничего не возвращает. Она совершает только полезное действие &mdash; вывод информации в терминал.
