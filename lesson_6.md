# Урок 6. Собственные функции

На прошлых уроках мы узнали, что:
- функция &mdash; это специальный именованный объект, который содержит готовый к исполнению код;
- содержащийся внутри (или *в теле*) функции код исполняется, когда мы *вызываем* функцию, приставив к ее имени круглые скобки;
- у функции могут быть *параметры* &mdash; имена, которые описываются в *сигнатуре* функции. Например, `print(*objects)`, где `print` &mdash; имя функции, а `*objects` &mdash; имя параметра;
- с помощью параметров разработчики функции обозначают, что при вызове функции ей (внутри круглых скобок) должны или могут быть переданы те или иные объекты. Эти объекты называют *аргументами*. Например, `print('Привет')` означает вызов функции `print` с аргументом `'Привет'` для параметра `*objects`
- имена-параметры служат по сути переменными, к которым мы привязываем объекты-аргументы, чтобы потом различать эти объекты внутри функции;
- в сигнатуре функции параметры могут сопровождаться *дефолтными аргументами*, т.е. объектами, которые будут задействованы внутри функции, если для данного параметра при вызове функции ничего другого передано не будет;
- если вас устраивают дефолтные аргументы, то приводить их при вызове функции не требуется;
- параметры могут быть разных типов. Мы пока узнали три: 1) позиционные параметры переменной длины (начинаются с `*`); 2) исключительно позиционные параметры (все параметры до косой черты `/`); 3) позиционные-или-именованные параметры
- любая функция всегда возвращает какой-то объект: либо специальный объект "ничто" (None) либо какой-то иной, "полезный" объект. Например, функция `print` возвращает None, а функция `input` возвращает текст, который ввел пользователь.

`print` и `input` &mdash; это *встроенные* функции, написанные до нас и изначально доступные интерпретатору. Мы можем создавать (определять) собственные функции или, как их именуют в документации, *user-defined functions* (функции, определенные пользователем, где под пользователем подразумевается автор кода).

## Собственная функция: необходимый минимум

В самом минимальном варианте нам понадобятся:
- ключевое слово `def`
- имя функции (нужно придумать самим)
- круглые скобки, после которых сразу идет двоеточие
- тело функции, которое должно начинаться с *отступа* со следующей строки.

Требования к именам функции те же, что и к переменным: латиница и выразительность.

Например, мы хотим написать (*определить*) функцию, которая будет суммировать два числа. Подходящее выразительное имя: `sum_two_numbers`. Иными словами, по названию функции должно быть хотя бы примерно понятно, что она делает.

Начнем создавать функцию (работаем в интерпретаторе в интерактивном режиме). Введите следующий код, Enter в конце **не** нажимайте.
```
>>> def sum_two_numbers():
```

Ещё раз:
- `def`
- пробел
- имя функции
- без пробела круглые скобки
- без пробела двоеточие

Как вы поняли, процесс определения функции ещё не закончен, поэтому, когда мы нажмем Enter, интерпретатор **не** покажет нам новое приглашение ввести команду (`>>>`). Он будет ждать ввода тела функции.

Нажмите Enter.

```
>>> def sum_two_numbers():
...
```

Вместо елочки появилось троеточие. В интерпретаторе это означает, что ввод инструкции продолжается.

Мы начинаем вводить тело функции. Как уже было сказано выше, тело функции должно начинаться с отступа (`indent`). Отступ равен 4 пробелам. Вместо их ввода достаточно нажать клавишу Tab. Нажимаем и видим как курсор сдвинулся вправо.

Теперь давайте напишем тело функции из одной строки &mdash; вызова функции `print` с текстом `'Мы создали первую функцию!'`.

Вводим тело функции и нажимаем Enter. Снова появится троеточие.

Должно выглядеть вот так.

```
>>> def sum_two_numbers():
...     print('Мы создали первую функцию!')
...
```

Интерпретатор ожидает, что мы продолжим писать код в теле функции. Если бы это было действительно так, то нужно было бы снова сделать отступ и вводить следующую строку кода в теле функции. 

Но у нас тело функции ограничивается одной строкой кода, поэтому нажимаем еще раз Enter, что означает завершение определения функции.

Должна появится "елочка", т.е. приглашение ввести следующую инструкцию. Это значит, что ввод предыдущей инструкции (определение функции) завершен.

```
>>> def sum_two_numbers():
...     print('Мы создали первую функцию!')
...
>>>
```

Отлично! Вот мы и создали нашу первую функцию. Давайте проверим, что интерпретатор ее "знает" (она записана в оперативную память). Наберите имя функции (без вызова) и нажмите Enter. Посмотрите, что ответил интерпретатор.

```
>>> sum_two_numbers
<function sum_two_numbers at 0x000001D8D593CE00>
>>>
```

Интерпретатор узнал это имя и вывел *строковое (текстовое) представление объекта*, который за этим именем скрывается. У функции, как и у любого объекта в Python, есть внутренний метод, который автоматически формирует ее описание.

Это описание стандартно и состоит из трех элементов:
- слова `function`
- имени функции
- идентификатора ячейки в памяти, куда записана функция после ее определения. Пример `at 0x000001D8D593CE00`, где `0x...` идентификатор ячейки.

Тут будет уместно напомнить наш разбор функции `print` и тот момент, когда мы рассуждали про *строковое представление объектов*. Напомню, что строковое представление объектов классов `int`, `float`, `str`, не что иное как цифры и текст, содержащиеся в этих объектах.

Для более сложных объектов (вспоминаем пример с объектом "Кот Барсик") разработчики придумывают свое описание, читая которое можно понять, что за объект под этим описанием скрывается.

Давайте передадим функции `print` объект нашей собственной функции.

```
>>> print(sum_two_numbers)
<function sum_two_numbers at 0x000001D8D593CE00>
>>>
```
Этот пример призван продемонстрировать и напомнить 2 вещи:
- функция `print` работает не только с числами и текстом, а вообще с любыми объектами;
- у любого объекта есть его текстовое описание (строковое представление). Поэтому `Привет` в терминале это *строковое представление* объекта класса `str` `'Привет'`, а `<function sum_two_numbers at 0x000001D8D593CE00>` - это *строковое представление* объекта-функции `sum_two_numbers`

Ну а теперь давайте вызовем нашу функцию и посмотрим на ее работу.

```
>>> sum_two_numbers()
Мы создали первую функцию!
>>>
```

Думаем как интерпретатор. Что произошло при вызове функции? При вызове функции **был исполнен код, который находится в ее теле**.

Интерпретатор зашел в тело функции, считал единственное содержащееся там выражение `print(sum_two_numbers)` и исполнил его.

Да, кстати, этот пример показывает, что в теле функции может быть вообще любой код, в том числе вызовы других функций.

Рассматривайте функцию как мини-программу внутри вашей основной программы, которую можно неоднократно запускать (вызывать) в разных частях основной программы.

**Важный момент**: код в теле функции **не исполняется** до тех пор, пока функция не будет вызвана. К примеру, если в теле функции указан вызов `print()`, этот вызов реально произойдет тогда, когда функция начнет исполняться (будет вызвана). Когда интерпретатор считывает определение функции, он просто запоминает ее код, но ничего с ним не делает.

## Параметры функции

Доработаем нашу первую функцию. Она работает, но делает не то, что следует из ее названия. А должна она, исходя из названия, складывать 2 числа.

Первое что нужно сделать &mdash; дополнить определение функции параметрами. Раз функция предназначена для сложения двух чисел, то и параметров должно быть два, для левого и для правого числа.

Параметрам, как мы знаем, нужны имена. Опять же, как и для всех остальных имен, правило &mdash; имена должны быть выразительными. Можно, конечно, именовать один параметр `a`, а другой `b`. Для маленьких функций и небольших программ это некритично. Но лучше сразу всё делать по науке. Когда спустя недели или месяцы вам понадобится вернуться к собственному коду, вы скажете себе "спасибо", быстро восстанавливая логику кода благодаря понятным именам.

Итак, пусть параметр для левого числа называется `left_number`, а для правого `right_number`.

Тогда определение нашей функции будет выглядеть так:

```
def sum_two_numbers(left_number, right_number):
```

Введем этот код в интерпретаторе. Если у вас возникнет вопрос, а как же предыдущее определение функции с тем же именем, то вот ответ: ошибки не будет, новое определение "затрет" предыдущее. Поэтому нужно быть внимательным: если у вас в коде окажется 2 определения функции с одним и тем же именем, то нижнее определение "перебьет" верхнее определение (так как, мы помним, интерпретатор читает код сверху вниз).

Нажимаем `Enter`

```
>>> def sum_two_numbers(left_number, right_number):      
...
```

Теперь, кстати, давайте посмотрим, а что будет если мы не сделаем отступ?

Не нажимая Tab (т.е. не делая отступ), нажмите еще раз Enter.

```
>>> def sum_two_numbers(left_number, right_number):      
...
  File "<stdin>", line 2

    ^
IndentationError: expected an indented block after function definition on line 1
>>>
```

Вы получите ошибку класса `IndetationError` или в переводе "ошибку отступа". Описание ошибки очень понятное: "ожидается блок кода с отступом после определения функции".

Вернитесь в интерпретатор и нажмите на клавиатуре кнопку "Стрелка вверх". С помощью стрелок вверх-вниз вы можете перемещаться по истории команд.

Один раз нажав стрелку вверх вы увидите снова строку с определением функции.

```
>>> def sum_two_numbers(left_number, right_number): 
```

Нажимаем `Enter`, далее `Tab` (делаем отступ) и вводим выражение для сложения двух чисел. Помним, что объекты чисел у нас скрываются под именами параметров

> Параметры по сути выступают переменными, к которым привязываются объекты-аргументы при вызове функции

Выражение сложения двух объектов-чисел присвоим переменной `result`

Должно получиться так

```
>>> def sum_two_numbers(left_number, right_number):      
...     result = left_number + right_number
...
```

Нажимаем еще раз Enter, чтобы завершить определение функции.

```
>>> def sum_two_numbers(left_number, right_number):      
...     result = left_number + right_number
...
>>>
```

## Запуск функции с параметрами. Обязательные аргументы

Итак, мы определили функцию с двумя параметрами:
- `left_number`
- `right_number`

Эти параметры, как мы уже знаем, являются "позиционными-или-именованными", поэтому, если первое слагаемое `5`, а второе `6`, то эти объекты в качестве аргументов мы можем при вызове функции передать ровно четырьмя способами:
1. `sum_two_numbers(5, 6)`
2. `sum_two_numbers(5, right_number=6)`
3. `sum_two_numbers(left_number=5, right_number=6)`
4. `sum_two_numbers(right_number=6, left_number=5)`

В первом случае мы передаем оба аргументы как позиционные, следовательно, 5, как первый аргумент, привязывается к первому параметру, т.е. к `left_number`. Аргумент `6`, как второй по счету, привязывается ко второму по счету параметру, т.е. к `right_number`.

Во втором случае мы передаем первый аргумент как позиционный, соответственно 5 привязывается к параметру на первой позиции, т.е. к `left_number`. Второй аргумент мы передаем как именованный, т.е. сразу в сопровождении параметра.

В третьем и четвертом случаях мы оба аргумента передаем как именованные, поэтому очередность их передачи значения не имеет (что и видно из примеров).

Теперь освежим в памяти, как аргументы **нельзя** передавать:

1. `sum_two_numbers(left_number=5, 6)`

Причина: именованный аргумент никогда не может стоять перед позиционным.

В противном случае будет ошибка:

```
SyntaxError: positional argument follows keyword argument
```

2. `sum_two_numbers(6, left_number=5)`

Допустим, пытаясь исправить предыдущую ошибку, мы решили поменять аргументы местами. Решили, что интерпретатор догадается, что раз `left_number=5`, то `6` надо привязать к `right_number`.

Но нет, получим ошибку

```
TypeError: sum_two_numbers() got multiple values for argument 'left_number'
```

Интерпретатор говорит: в качестве аргумента для параметра `left_number` передали не один, а несколько объектов.

**Запоминаем**: интерпретатор читает код сверху вниз и слева направо.

Когда он читает вызов функции `sum_two_numbers(6, left_number=5)`, то сначала он читает позиционный аргумент `6`, а раз он позиционный и идет первым, то привязывается к первому параметру, т.е. `left_number`. Далее интерпретатор видит, что мы опять обращаемся к параметру `left_number` и пытаемся присвоить ему ещё один аргумент (`5`). Вот и ошибка.

Что будет, если мы вызовем нашу функцию с 1 аргументом или вообще без них?

Если при вызове функции для параметра **не передать** аргумент, то будет ошибка **кроме двух случаев**:
1. В определении функции у параметра есть *дефолтный аргумент*
2. Параметр имеет переменную длину, а значит, может принимать не только неопределенное число аргументов, но и вообще ни одного (как, к примеру, функция `print`, у которой первый параметр `*objects` принимает 0 и более аргументов).

Смотрим на определение нашей функции:

```
def sum_two_numbers(left_number, right_number):
```

Видим, что ни один из параметров не подходит под исключения. Значит, если не передать аргумент хотя бы для одного параметра, будет ошибка.

Пробуем.

```
>>> sum_two_numbers()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: sum_two_numbers() missing 2 required positional arguments: 'left_number' and 'right_number'
>>> sum_two_numbers(5)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: sum_two_numbers() missing 1 required positional argument: 'right_number'
>>>
```

Каждый раз мы получили ошибку класса `TypeError`. В расшифровке ключевая фраза `missing argument(s)`. Если видите эти слова, значит, забыли передать обязательный аргумент.

**Запоминаем**: при вызове функции, в определении которой есть параметры, следует обязательно передавать аргументы для этих параметров. Есть 2 исключения (описаны выше).

## Область имен функции и глобальное пространство имен

Давайте вызовем нашу функцию, передав ей два аргумента &mdash; числа 5 и 6.

```
>>> sum_two_numbers(5, 6)
>>>
```

Вызов отработал, ошибок нет, но и видимого результата тоже...

Обратимся к телу функции:

```
result = left_number + right_number
```

Запустив функцию, мы выполнили инструкцию присваивания переменной `result` результата выражения `left_number + right_number`, где за каждой переменной стоит объект целого числа.

Это *всё*, что делает сейчас наша функция, поэтому мы ничего не видим в интерпретаторе.

Так, можете подумать, вы, ну тогда у нас есть переменная `result`, которая указывает на объект числа 11. И мы можем ее использовать дальше в нашей программе!

Давайте попробуем. Обратимся к переменной `result`, которая объявлялась при вызове функции `sum_two_numbers`.

```
>>> sum_two_numbers(5, 6)
>>> result
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'result' is not defined
>>>
```

И мы получаем ошибку! Интерпретатор не знает имени `result`!

Объясняю, почему так.

Выше я уже говорил, что функцию можно рассматривать как мини-программу внутри основной программы.

Так вот у функции, этой мини-программы, свое *пространство имен*. Проще говоря, все переменные, которые объявляются внутри функции:
- считаются частью ее пространства имен;
- доступны **только внутри функции**;
- **исчезают** после отработки вызова функции.

Представьте вашу программу в виде длинного коридора. Вдоль коридора, слева и справа, закрытые двери.

Коридор &mdash; это основная программа. Вы &mdash; интерпретатор. Ваше движение по коридору, шаг за шагом, это исполнение программы. Дойдя до конца коридора вы исполняете программу целиком.

По ходу вашего движения вы можете открывать ту или иную дверь и заходить в соответствующее помещение. Вот это вызов функции. Открыли дверь &mdash; вызвали функцию. Вы заходите в помещение, что-то там делаете &mdash; это исполнение функции. Далее, когда вы закончили свои дела в помещении, вы выходите обратно в коридор - функция исполнена, а вы (интерпретатор) вернулись в  коридор (основную программу) и идете дальше к следующей двери (следующему вызову какой-либо функции).

Так вот, когда вы закрыли двери (завершили исполнение функции), всё что происходило в помещении, остается там, если вы *что-то не забрали оттуда* (как забрать - скажем, чуть позже).

Поэтому созданная при исполнении функции `sum_two_numbers` переменная `result`, указывающая на объект числа 11, **исчезает** после того, как функция завершила свою работу.

Переменные, объявленные внутри функции, составляют *пространство имен этой функции*. В свою очередь, имена, которые доступны в основной программе, составляют *глобальное пространство имен*.

**Запоминаем**:
1. Имена переменных, которые объявляются внутри функции, относятся к *пространству имен данной функции*. Этими именами интерпретатор может оперировать только в момент исполнения функции. Как только исполнение функции завершается имена, принадлежащие ее пространству имен, больше не доступны.

2. В пространстве имен функции, наоборот, **доступны** все имена из глобального пространства. Это логично, иначе, как бы мы, к примеру, создавали объекты чисел внутри функции, если находясь в ней интерпретатор не видел бы класс чисел `int`? Или другой пример, который вы уже видели, &mdash; когда мы внутри функции `sum_two_numbers` описывали вызов встроенной функции `print`. Имя `print` живет в глобальном пространстве имен.

3. Имена классов и функций из глобального пространства имен можно использовать внутри собственных функций непосредственно (т.е. просто указать соответствующее имя, например, `print`). **Имена переменных** из глобального пространства при использовании внутри функции нужно сопровождать специальным словом `global`. Так интерпретатор сможет отличить переменную из глобального пространства от переменной из локального пространства.

На протяжении этого курса вы вряд ли столкнетесь с необходимостью использовать переменные из глобального пространства в теле функций, но я всё равно покажу, как это работает, чтобы было понятно.

Итак, возвращаемся в интерпретатор.

Объявляем переменную `result` и присваиваем ей объект числа 10.

```py
>>> result = 10
```

Имя `result` существует в *глобальном пространстве имен*.

Теперь пересоздадим функцию `sum_two_numbers` и в ее теле обратимся к глобальной переменной `result`. Повторяем за мной:

```
>>> def sum_two_numbers(left_number, right_number):  
...     global result
...     result = left_number + right_number
...
>>> sum_two_numbers(5, 8)
>>> result
13
>>>
```

Ставим себя на место интерпретатора.

Интерпретатор доходит до строки `def sum_two_numbers(left_number, right_number):`, считывает определение функции и записывает ее в память под именем `sum_two_numbers`. Это имя находится в глобальном пространстве имен.

Далее интерпретатор переходит к следующей строке: `sum_two_numbers(5, 8)`. Здесь находится *выражение* вызова функции `sum_two_numbers` с аргументами `5` и `8`.

Исполнение основной программы "заворачивает" в исполнение мини-программы в теле функции `sum_two_number`.

Поэтому следующий шаг интерпретатора &mdash; исполнение первой инструкции из тела вызванной функции. Это инструкция `global result`. Из нее интерпретатор понимает, что переменная `result` &mdash; это переменная, ранее созданная в глобальном пространстве имен (мы помним `result = 10`).

Далее интерпретатор переходит ко второй (заключительной) инструкции в теле функции: `result = left_number + right_number`.

В рамках этой инструкции выполняется выражение сложения чисел из аргументов `left_number` (число 5) и `right_number` (число 8) с дальнейшим присвоением созданного объекта (число 13) **глобальной** переменной `result`. С помощью оператора присваивания `=` мы перепривязали переменную `result` к новому объекту, теперь переменная указывает не на число 10, а на число 13.

На этом исполнение функции закончилось, интерпретатор возвращается в основную программу и переходит к строке, где мы просто обращаемся к переменной `result`. Интерпретатор предсказуемо отвечает &mdash; за этой переменной скрывается число 13.

## Результат работы функции. Инструкция `return`

Условно функции можно разделить на 3 вида:
1. Совершают какое-то внешнее действие (выводят информацию в терминал, создают файл, отправляют запрос по сети и т.д.), но ничего не возвращают (т.е. возвращают объект `None`)
2. Не совершают никаких внешних действий, но создают (вычисляют) новый объект, как правило, на основе переданных аргументов, и возвращают этот новый объект
3. Совершают какое-то внешнее действие, и возвращают новый объект, который мы дальше используем в коде программы.

Когда мы с вами объявили функцию

```
>>> def sum_two_numbers(left_number, right_number):    
...     result = left_number + right_number
```

мы создали бесполезную функцию. Она не совершает никаких внешних действий и не возвращает новый объект для дальнейшего использования в программе. Она просто внутри себя производит некое вычисление, результат которого никому не доступен и исчезает вместе с завершением работы функции.

Функция в том виде, что представлена выше, возвращает объект `None`. Как я это определил? По отсутствию ключевого слова `return` в конце тела функции.

Благодаря ключевому слову `return` происходят 2 вещи:
- функция прекращает свою работу;
- функция возвращает объект, который указан рядом с этим ключевым словом
- если рядом с ключевым словом `return` не указано ничего, функция возвращает `None`. Таким образом, отсутствие вообще слова `return` в теле функции или присутствие, но без указания рядом возвращаемого объекта, равносильны.

**Важно**: после `return` никакого кода в теле функции быть не должно. Этот код просто не будет исполнен, т.к. `return` прекращает работу функции.

Давайте посмотрим на примерах:

```
>>> def test():
...     print('Мы запустили функцию test')
...     return 5
...
>>> num_from_test = test()
Мы запустили функцию test
>>> num_from_test
5
>>>
```

Мы объявили функцию `test`, которая при вызове:
- выводит в терминал сообщение `Мы запустили функцию test`
- **возвращает** (return) число 5 (не ищите логики, почему 5, а не 10, 1000 или 5679, тут просто демонстрируется механизм возврата *любого* объекта)

Далее мы вызвали функцию `test` и возвращенный ею объект привязали к переменной `num_from_test`. Таким образом, в ходе исполнения инструкции `num_from_test = test()` произошло 2 вещи:
- сначала в теле функции `test` отработал вызов функции `print` и мы увидели сообщение в терминале
- затем сработала инструкция `return 5` и этот объект (число 5) был привязан к переменной `num_from_test`.

Наконец мы обратились к переменной `num_from_test` и получили от интерпретатора ожидаемый ответ &mdash; за переменной скрывает объект числа 5.

А теперь поменяем местами инструкции в теле функции `test`.

```py
>>> def test():
...     return 5
...     print('Мы запустили функцию test')
...
>>> num_from_test = test()
>>> num_from_test
5
>>>
```

Видите в чем отличие в работе функции от предыдущего варианта? Сообщение `Мы запустили функцию test` не отобразилось. Почему? Потому что оно расположено **после** return, а значит, осталось не исполненным, т.к. `return` завершает работу функции.

Таким образом, отработала только инструкция `return 5`.

Вернемся к нашей функции `sum_two_numbers`.

Доработаем функцию, чтобы она одновременное и совершала внешнее действие (к примеру, вывод информации в терминал), и возвращала вычисленное значение.

Набираем в интерпретаторе

```py
>>> def sum_two_numbers(left_number, right_number):
...     result = left_number + right_number
...     print(left_number, '+', right_number, '=', result)      
...     return result
...
>>> result = sum_two_numbers(5, 9)
5 + 9 = 14
>>> result
14
```

Логика работы ровно та же, что описывалась чуть выше для функции `test`:
- при вызове функции из переданных аргументов вычисляется новый объект (сумма) и привязывается к переменной `result`, **объявленной в пространстве имен функции**
- совершается внешнее действие &mdash; выводится текст в терминал с помощью вызова встроенной функции `print`
- с помощью инструкции `return result` функция завершает свою работу и возвращает в основную программу объект числа, стоящий за переменной `result`. Сама переменная, поскольку относилась к пространству имен функции, исчезает
- теперь, **внимание**, мы создаем **другую переменную** `result`, уже в глобальном пространстве имен и привязываем к ней объект, который вернул вызов функции `sum_two_numbers`.

Поэтому пусть вас не смущают две одноименные переменные. Они разные, поскольку были созданы в разных пространствах имен.

В зависимости от того, какую мы перед собой задачу ставим, наша функция могла бы выглядеть иначе:
1. Совершать внешнее действие, но ничего не возвращать.

```py
def sum_two_numbers(left_number, right_number):
    result = left_number + right_number
    print(left_number, '+', right_number, '=', result)      
```

Видим, что инструкции `return` нет, что равносильно `return` без объекта или `return None`.

2. Не совершать внешнее действие, но создавать (вычислять) и возвращать новый объект.

```
def sum_two_numbers(left_number, right_number):
    result = left_number + right_number
    return result
```

## Аннотации к функции

Интуитивно понятные имена функции и ее параметров &mdash; это круто и must have при определении любой функции.

Но можно (и нужно) пойти ещё дальше в придании функции максимальной читабельности со стороны человека.

Для этого используют *аннотации*.

Обратимся к определению в [документации](https://docs.python.org/3/glossary.html#term-annotation):

> annotation &mdash; a label associated with a variable, a class attribute or *a function parameter* or *return value*, used by convention as **a type hint**.

Из определения следует, что применительно к функциям аннотация &mdash; это метка, которая "подсказывает", объекты каких классов ("типов"):
- ожидаются в качестве аргументов для конкретного параметра функции
- будут возвращены функцией.

Аннотация используется в качестве **type hint** ("тайп хинт", "подсказка о типе"). Таким образом, аннотацию функции и тайп хинт можно рассматривать как синонимы.

Добавим аннотации к нашей функции `sum_two_numbers`, но перед этим нужно понять 2 вещи:
- объекты каких классов ожидаются в качестве аргументов для каждого параметра
- объект какого класса вернет наша функция

Отвечаем:
- для параметра `left_number` ожидается объект-аргумент класса `int` или класса `float` (т.е. нам главное, чтобы было число, а какое оно, целое или с дробной частью, неважно)
- для параметра `right_number` всё то же самое
- функция возвращает или объект класса `int` (если складывали целые числа), или объект класса `float` (если хотя бы одно из слагаемых число с дробной частью)

Отлично. Переведем эту информацию в формат аннотаций.

```
>>> def sum_two_numbers(left_number: int | float, right_number: int  | float) -> int | float:
...     result = left_number + right_number
...     print(left_number, '+', right_number, '=', result)       
...     return result
...
```

Объясняю:
- аннотация к параметру оформляется так:
  - параметр
  - двоеточие
  - пробел
  - класс или классы, объектом которых должен быть аргумент для этого параметра
  - знак `|` (логическое ИЛИ) означает, что допускаются объекты любого из перечисленных классов (в случае `int | float` &mdash; или целое число, или число с дробной частью)
- аннотация к возвращаемому функцией значению оформляется так:
  - пробел после правой (закрывающей) скобки с параметрами функции
  - "стрелочка", составленная из дефиса и правой угловой скобки (`->`)
  - пробел
  - название класса или классов, объект которых возвращает функция. В нашем случае возвращаемый объект может относиться либо к классу `int`, либо `float` (`int | float`)
  - если функция возвращает None (ничего не возвращает), то так и указывают `-> None`

**Внимание**: если вы не устанавливали интерпретатор Python в рамках подготовительного урока, учтите, что синтаксис тайп хинтс с использованием символа `|` **не работает** в версиях Python ниже 3.10.

## Docstring &mdash; документирование функции

Аннотации значительно повышают ясность вашего кода. Впервые читая код той или иной функции, вы сразу понимаете, аргументы каких классов ожидает функция и объекты каких классов она возвращает.

Но можно (и нужно) пойти ещё дальше в деле максимальной ясности вашего кода. Нужно *задокументировать* функцию &mdash; объяснить простыми словами, что именно она делает, для чего нужен каждый из параметров.

Текст с описанием работы функции называется `docstring` (докстринг). Он заключается в три двойные кавычки в начале и в конце и размещается перед телом функции. Использование трех двойных кавычек позволяют создавать multiline string, т.е. размещать текст на нескольких строках, перенося их клавишей Enter.

Вот как это выглядит:

```py
def sum_two_numbers(left_number: int | float = 0,
                    right_number: int  | float = 0) -> int | float:
    """Сложить два числа, результат вывести в терминал и вернуть.
    
    Args:
        `left_number`: первое слагаемое, дефолтное значение `0`
        `right_number`: второе слагаемое, дефолтное значение `0`
    
    Returns:
        всегда возвращается число - сумма `left_number` и `right_number`
    """
```

1. Открываем docstring &mdash; ставим три двойные кавычки.
2. В свободной форме описываем, что делает функция.
3. Нажимаем Enter, еще раз Enter (чтобы появилась пустая строка)
4. Далее описываем блок `Args`, посвященный параметрам и аргументам
5. Построчно (делая отступ клавишей Tab) указываем параметр и через двоеточие и пробел, для чего он нужен
   - имена параметров и значения аргументов я обернул символом ` (backtick, "обратная галочка", на клавиатуре обычно находится слева от клавиши с цифрой 1)
   - такая обертка не обязательна, но она помогает отделить имена и значения от остального текста (в том числе при визуализации docstring в редакторе кода, чуть позже я покажу, что это)
6. Далее через пустую строку мы описываем блок `Returns:`, где рассказываем в свободной форме, что возвращает наша функция. В примере указано "всегда возвращается", так как других вариантов поведения данной функции нет. Но вполне может быть функция, которая может вариативно возвращать разные объекты. Тогда мы описываем построчно каждый вариант &mdash; при каких обстоятельствах вернется тот или иной объект.
7. Закрываем docstring &mdash; ставим три двойные кавычки.

Создайте в директории `programming` новый Python-скрипт, назовите его `02_first_function.py`.

Перепишите в него следующий код. Попутно проверяйте себя: всё ли вам в нём понятно, если нет &mdash; перечитайте урок.

```py
def sum_two_numbers(left_number: int | float = 0,
                    right_number: int  | float = 0) -> int | float:
    """Сложить два числа, результат вывести в терминал и вернуть.
    
    Args:
        `left_number`: первое слагаемое, дефолтное значение `0`
        `right_number`: второе слагаемое, дефолтное значение `0`
    
    Returns:
        всегда возвращается число - сумма `left_number` и `right_number`
    """
    result = left_number + right_number
    print(left_number, '+', right_number, '=', result)
    return result


sum_two_numbers()
sum_two_numbers(left_number=5)
sum_two_numbers(right_number=8)
sum_two_numbers(5, 8)
sum_two_numbers(right_number=5, left_number=8)
```

Обратите внимание при наборе кода:
1. Для отступов, как и в интерпретаторе, используйте клавишу Tab. Редактор кода по умолчанию настроен так, что при нажатии этой клавиши он поставит ровно 4 пробела.
2. Поскольку объявление функции получилось очень длинным

```py
def sum_two_numbers(left_number: int | float = 0, right_number: int  | float = 0) -> int | float:
```

мы разместили параметры с помощью клавиши Enter друг под другом. Всё ради большей читаемости кода.

```py
def sum_two_numbers(left_number: int | float = 0,
                    right_number: int  | float = 0) -> int | float:
```

3. Для каждого параметра помимо аннотации мы указали дефолтное значение (` = 0`). Формат: пробел, =, пробел, дефолтное значение.

На всякий случай &mdash; полный код скрипта.

Запустите созданный скрипт. В терминале вы должны увидеть

```
...programming/02_first_function.py
0 + 0 = 0
5 + 0 = 5
0 + 8 = 8
5 + 8 = 13
8 + 5 = 13
```

Сопоставьте каждый вызов функции с выводом в терминал. Убедитесь, что вам на 100% ясно, почему вывод именно такой.

## Заключение

Подведем итоги.

1. Чтобы создать (определить, объявить) функцию мы используем ключевое слово `def`.

2. У функции должно быть имя, которое мы придумываем сами. Имя должно давать примерное понимание, что делает функция.

3. У функции может быть 1 или несколько параметров. Параметры указываются в круглых скобках сразу после имени функции. Например, `def some_func(param1, param2, ...)`

Если у функции нет параметров, после ее имени нужно указать пустые круглые скобки, например, `def some_func()`

4. После имени функции и ее параметров ставится двоеточие, а далее, с новой строки и одним **отступом** (indent) описывается *тело функции*, т.е. код, который будет исполнен при вызове функции.

5. Все имена классов, функций, переменных, которые объявляются в основном коде программы, а также имена встроенных классов и функций существуют в *глобальном пространстве имен*. Эти имена доступны в любом месте программы, в том числе, в теле любой функции.

6. Имена, которые объявляются внутри тела функции, находятся в ограниченном пространстве &mdash; пространстве имен данной функции. Эти имена исчезают после завершения работы функции.

7. Чтобы использовать в дальнейшем объект, который создала ("вернула") функция, используем ключевое слово `return`, после которого указываем объект (в том числе в виде переменной), который возвращает функция.

8. Инструкция `return` **завершает работу функции**. Если указать какой-то код после этой инструкции в теле функции, этот код исполнен **не будет**.

9. Для повышения читаемости кода человеком (вами или другими программистами) следует сопровождать каждую функцию:
- аннотациями ("тайп хинтами"), которые позволяют понять, объекты каких классов функция ожидает на вход (т.е. в качестве аргументов при вызове), объекты каких классов возвращает функция
- документацией (docstring), из которой можно быстро понять, что конкретно делает функция, для чего предназначен каждый из ее параметров, что именно она возвращает в разных сценариях использования.
