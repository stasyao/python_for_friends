# Урок 4. Функция `input`. Символ новой строки. Пустая строка

## Функция `input` &mdash; приемник информации от пользователя

В предыдущем уроке мы познакомились с встроенной функцией `print`.

Сегодня мы познакомимся с ещё одной встроенной в интерпретатор функцией &mdash; функцией `input`.

Вот что делает функция `input` при вызове:
- работа программы приостанавливается
- программа ждет *ввода какого-либо текста* от пользователя. Ввод текста осуществляется в окне терминала (или непосредственно в интерпретаторе, если мы работаем с ним в интерактивном режиме)
- окончание ввода пользователем текста фиксируется нажатием им (пользователем) клавиши Enter, что означает простановку специального символа `\n` (newline, перевод на новую строку или, как выражаются еще со времен печатных машинок, "перевод каретки")
- после нажатия пользователем клавиши Enter, функция `input` *возвращает* введенную пользователем информацию в виде строкового объекта (объекта класса `str`). Соответственно этот объект можно дальше использовать в коде программы. Символ `\n`, которым был завершен в введенный текст при нажатии клавиши Enter, в состав принятой строки **не** входит.

**Обратите внимание**: это очень важный момент &mdash; функция `input` **всегда** возвращает объект исключительно класса `str`. Пока просто запомните это, далее в уроке мы убедимся, почему это действительно важная информация.

Давайте попробуем новую функцию!

Запускаем интерпретатор в интерактивном режиме и вызываем функцию `input`. Эту функцию **можно вызвать без аргументов** (подробнее о сигнатуре поговорим в следующем подразделе)

```py
>>> input()

```

Что произошло после вызова?

Интерпретатор "застыл". На новой строке нет "елочки", символизирующей приглашение ввести команду. Сейчас интерпретатор ждет от вас ввод какой-либо информации, которая будет превращена функцией `input` в строковый объект.

Давайте введём текст `привет`. Тут важный момент: кавычками окружать текст **не нужно** (если только они не являются частью текста). Мы сейчас не создаем строковой объект. Мы "обычные" пользователи, которым программа предлагает передать ей какую-то информацию. Дальнейшие превращения этой информации в объект языка Python происходит уже "под капотом".

Итак

```py
>>> input()
привет
```

Ввели текст `привет`, нажимаем Enter.

```py
>>> input()
привет
'привет'
>>>
```

Что мы видим? Функция вернула `'привет'` &mdash; объект класса `str`. Снова напоминаю, что окружающие текст `привет` кавычки являются служебными и символизируют текстовый объект.

Давайте введем какое-нибудь число.

```py
>>> input()
2
'2'
>>>
```

Обратите внимание: функция `input` вернула не объект класса `int` со значением `2`. Функция вернула **строковый объект**, значение которого &mdash; **текст** из одного символа `2`. Подсказкой нам служат служебные кавычки-лапки.

Напоминаю, что в коде Python-программы (именно в коде, не в пользовательском вводе):
- `2` &mdash; объект класса целых чисел (класса `int`)
- `'2'` &mdash; объект класса строк (класса `str`)

Вообще любой символ, будь то число или оператор (например, `=` или `+`), становится обычным текстом, как только "попадает" в кавычки.

## Разбираем сигнатуру функции `input`

Сигнатура функции `input` следующая

```py
input(prompt='', /)
```

Из сигнатуры мы видим, что у функции `input` есть единственный параметр по имени `prompt` (от англ. "prompt" &mdash; подсказка, приглашение) и он является опциональным (необязательным), так как содержит дефолтное значение.

Дефолтным значением является &mdash; `''`, две одинарных кавычки, между которыми ничего нет, даже пробела. Это **пустая строка**. Это объект класса `str`, который не содержит никакого текста. Пустая строка &mdash; полезный объект, мы ещё не раз столкнемся с его применением в коде.

О назначении параметра `prompt` поговорим чуть ниже, а сейчас обратите внимание на косую черту (`/`) в конце списка параметров.

Косая черта при перечислении параметров означает, что все параметры, которые расположены **до нее**, являются **исключительно позиционными**. Соответственно аргументы они принимают только позиционные (т.е. формат `имя_параметра=аргумент` **не поддерживается**).

Давайте проверим &mdash; сделаем вызов функции `input` с дефолтным аргументом для параметра `prompt`, но передадим этот аргумент как именованный.

```py
>>> input(prompt='')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: input() takes no keyword arguments      
>>>
```

Мы получили ошибку класса `TypeError`. В описании ошибки сказано, что функция `input` **не** принимает именованные аргументы (keyword arguments). Это сработала косая черта, которую мы видели в сигнатуре.

**Запоминаем**: видите косую черту в сигнатуре функции &mdash; передавайте аргументы для параметров, расположенных до косой черты исключительно в качестве позиционных.

Теперь наконец поговорим о том, для чего вообще нужен позиционный параметр `prompt`. Аргументом для этого параметра является строковый объект, который мы хотим видеть в качестве "приглашения". По сути мы говорим о некоем тексте, который будет выводиться перед началом ввода и описывать, какие именно данные мы ждем от пользователя.

Давайте попрактикуем. Допустим, вам нужно получить от пользователя программы имя человека. Тогда "приглашение" может выглядеть так:

```py
>>> input('Введите ваше имя:')
Введите ваше имя:Стас
'Стас'
```

Строковый объект-аргумент `'Введите ваше имя:'` &mdash; это и есть то самое приглашение, после которого пользователь начинает вводить запрашиваемые данные.

Обратите внимание: ввод начинается сразу после окончания строки-приглашения. Поэтому в нашем случае вводимый пользователем текст "прилепляется" к окончанию строки приглашения (к двоеточию) `...имя:Стас`.

Поэтому часто бывает полезным в конце строки приглашения указывать пробел, чтобы *было красиво*.

Пробуем.

```py
>> input('Введите ваше имя: ')
Введите ваше имя: Стас
'Стас'
```

Обратите внимание на пробел между двоеточием и пользовательским вводом. Этот пробел не появился из ниоткуда, это часть строки, переданной для параметра `prompt`.

Потренируйтесь: придумайте 2-3 строки-приглашения для параметра `prompt` и вызовите с ними функцию `input`.

## Символ новой строки `\n` (newline character)

Символ `\n` (косая черта и сразу после нее латинская буква `n`) &mdash; это часть текста, которая означает, что с этого места последующая часть текста или новый текст должен отображаться на новой строке.

Посмотрите (и наберите сами в интерпретаторе!)

```py
>>> print('Весь текст в одну строку')
Весь текст в одну строку
>>> print('Текст\nв несколько\nстрок')
Текст
в несколько
строк
>>>
```

Во втором примере после слова `Текст` вместо пробела мы поставили символ новой строки `\n`. То же самое мы сделали после слова `несколько`.

Благодаря этому при выводе в терминал мы получили отображение не в одну строку, а в три:
- вторая строка началась сразу после первого `\n`
- третья строка началась сразу после второго `\n`

Давайте теперь потренируемся на реальном тексте (http://www.consultant.ru/legalnews/21979/).

Как создать строковый объект, который бы при выводе в терминал отображался идентично следующему фрагменту:

```
В пояснительной записке отметили, что Роспотребнадзор сможет отслеживать эти показатели по статотчетности и экстренным извещениям.

Сейчас используют только один индикатор: обнаружение химического вещества в концентрации выше допустимой границы.

Проект проходит общественное обсуждение до 8 апреля включительно.
```

Решение

```py
part_of_text = 'В пояснительной записке отметили, что Роспотребнадзор сможет отслеживать эти показатели по статотчетности и экстренным извещениям.\n\nСейчас используют только один индикатор: обнаружение химического вещества в концентрации выше допустимой границы.\n\nПроект проходит общественное обсуждение до 8 апреля включительно.'

print(part_of_text)
```

Обратите внимание: мы указали `\n` по два раза подряд. Тем самым мы сказали интрепетатору:
- начать новую строку (1-й `\n`)
- с новой строки сразу перейти на следующую новую строку (2-й `\n`). Тем самым мы получили по одной незаполненной строке между каждым абзацем.

Символ `\n` является примером так называемых "непечатаемых" (non-printable) символов. Они не отображаются при выводе текста в терминал, но управляют отображением текста, в частности, положением курсора.

**Запоминаем**: `\n` &mdash; не отображаемый символ (т.е. буквально символы `\n` в тексте мы не видим), который переводит курсор на новую строку и соответственно последующий или новый текст мы видим с новой строки.

### Использование `\n` и других аргументов в параметре `end` функции `print`

Вернемся к определению

*Символ `\n` (косая черта и сразу после нее латинская буква `n`) &mdash; это часть текста, которая означает, что с этого места последующая часть текста или новый текст должен отображаться на новой строке*.

В примере выше мы показали как символ `\n` работает для *последующей части* текста в рамках одного и того же строкового объекта.

Теперь разберем как символ `\n` работает при отображении *нового текста*.

Для этого вспомним сигнатуру функции `print`

```py
print(*objects, sep=' ', end='\n', file=None, flush=False)
```

На прошлом уроке мы разобрали первые два параметра (`*objects` и `sep`), теперь уместно поговорить о третьем параметре `end`.

Параметр `end` отвечает за то, что будет выведено в терминал после полной отработки функции. Дефолтное значение, как видно из сигнатуры, `\n`. Т.е. после отработки функции будет осуществлен перевод курсора на новую строку.

Давайте посмотрим, как будет меняться вывод в терминал при разных значениях `end`.

Создадим собственную функцию (пока просто копируйте, в деталях синтаксиса создания собственных функций поговорим позднее).

```py
def test():
    print('Первый вызов функции print', end='\n')
    print('Второй вызов функции print', end='\n')
    print('Третий вызов функции print', end='')
    print('Четвертый вызов функции print', end='')
    input('Input-приглашение: ')
```

Скопируйте и вставьте весь этот код в интерпретатор, работающий в интерактивном режиме.

При вставке VS Сode может запросить разрешение на вставку, нажмите `Paste` (разрешить вставку).

Должно получиться так

```py
>>> def test():
...     print('Первый вызов функции print', end='\n')
...     print('Второй вызов функции print', end='\n')
...     print('Третий вызов функции print', end='')
...     print('Четвертый вызов функции print', end='')
...     input('Input-приглашение: ')
```

Нажмите два раза Enter, чтобы интерпретатор принял объявление функции.

В результате должны снова появится "елочки" (приглашение от интерпретатора ввести новый код для исполнения).

```py
>>> def test():
...     print('Первый вызов функции print', end='\n')
...     print('Второй вызов функции print', end='\n')
...     print('Третий вызов функции print', end='')
...     print('Четвертый вызов функции print', end='')
...     input('Input-приглашение: ')
...
>>>
```

Вызовем нашу функцию `test`. При объявлении функции мы не указали ни одного параметра, поэтому и вызов будет без аргументов &mdash; просто указываем пустые круглые скобки.

```
>>> test()
Первый вызов функции print
Второй вызов функции print 
Третий вызов функции printЧетвертый вызов функции printInput-приглашение:
```

Исполнение функции остановится на ожидании пользовательского ввода, просто нажмите Enter (что означает ввод пустой строки) и функция завершит свою работу.

Разберем построчно работу функции.

```py
print('Первый вызов функции print', end='\n')
```

В терминал выведен текст `Первый вызов функции print`, в конце вывода сделан перевод на новую строку (это дефолтное поведение функции `print`, но для ясности я явно указал именованный аргумент `end='\n'`).

Таким образом, следующий вывод какого-либо сообщения в терминал (**не** обязательно от функции `print`, мы уже видели, что тот же `prompt` в `input`, это тоже сообщение, отображаемое в терминале) **будет произведен с новой строки**.

Это мы и видим после отработки второго вызова функции `print`.

```py
print('Первый вызов функции print', end='\n')
print('Второй вызов функции print', end='\n')
```

Текст `Второй вызов функции print` отобразился в терминале на следующей строке после текста `Первый вызов функции print` именно потому, что предыдущий вызов функции `print` был с `end='\n'`.

Мы можем точно определить, где будет выведено очередное сообщение в терминал, которое последует после текста `Второй вызов функции print`. Да, очередное сообщение будет также идти с новой строки, поскольку вызов `print('Второй вызов функции print')` закончился простановкой после выведенного текста `Второй вызов функции print` символа новой строки.

Это мы и видим в терминале:

```
Первый вызов функции print
Второй вызов функции print
Третий вызов функции print
```

Каждый новый текст идет с новой строки, поскольку вывод каждого предыдущего заканчивался (end) `\n`.

Теперь начинается самое интересное.

Обратите внимание на значение параметра `end` у третьего вызова функции `print`:

```py
print('Третий вызов функции print', end='')
```

Значение &mdash; пустая строка (`''`), а не символ новой строки. Это означает, что после отработки функции `print` курсор останется в конце выведенной строки, а не перейдет на новую строку.

Как тогда будет отображен текст при следующем вызове функции `print`? Правильно, он начнется сразу после предыдущего текста, буквально прилипнув к нему.

```py
print('Третий вызов функции print', end='')
print('Четвертый вызов функции print', end='')
```

Результат

```
Третий вызов функции printЧетвертый вызов функции print
```

Но и четвертый вызов `print` последовал с `end=''`. Значит, и следующее сообщение в терминале "слипнется" с предыдущим.

Именно поэтому текст `Input-приглашение` мы видим не с новой строки.

```
print('Третий вызов функции print', end='')
print('Четвертый вызов функции print', end='')
input('Input-приглашение: ')
```

```
Третий вызов функции printЧетвертый вызов функции printInput-приглашение:
```

**Запоминаем**: параметр `end` функции `print` позволяет регулировать 2 вещи:
- где окажется курсор после отработки вызов функции `print`
- будет ли выведен какой-то дополнительный текст.

Примеры для закрепления (если что-то неясно, спрашивайте):
- `end='\n'` &mdash; курсор окажется на следующей строке
- `end='\n\n'` &mdash; курсор окажется на две строки ниже (т.е. между следующим и текущим выводом в терминал будет пустая строка)
- `end=''` &mdash; курсор окажется на том же месте, где закончился выведенный текст.
- `end=' '` &mdash; курсор окажется в той же строке, на какой закончился выведенный текст, но через пробел от него
- `end=' abracadabra '` &mdash; после окончания выведенного текста будет отображен пробел, текст `abracadabra`, пробел. Курсор окажется в той же строке, на какой закончился выведенный текст
- `end=' abracadabra \n'` &mdash; всё то же самое, что и в предыдущем примере, только курсор окажется на новой строке.

### Использование `\n` в функции `input`

Перевод на новую строку в функции `input` используется в двух случаях.

Во-первых, символ новой строки автоматически проставляется после того, как пользователь завершил ввод и нажал Enter.

Это неизменяемая часть поведения функции `input`, благодаря которой всегда после окончания работы функции курсор оказывается на новой строке и соответственно вывод новых сообщений в терминал от новых вызовов разных функций осуществляется с новой строки.

Важно отметить: символ `\n` после пользовательского ввода **не** включается в возвращаемый функцией `input` текст.

Пример: пользователь ввел текст `привет` и нажал Enter для окончания ввода и перевода курсора на новую строку. Функция вернет объект `'привет'`, но не `'привет\n`.

Во-вторых, символ `\n` можно использовать при оформлении строки-приглашения (аргумента для параметра `prompt`).

К примеру, вы хотите, чтобы пользовательский ввод осуществлялся не в той же строке, что и приглашение, а с новой строки.

Давайте закодим это:

```py
>>> input('Введите текст:\n')
Введите текст:
привет
'привет'
```

Строка-приглашение содержит в себе текст `Введите текст:` и перевод курсора на новую строку.

Пользовательский ввод начинается сразу после окончания строки-приглашения. Поскольку строка-приглашение заканчивается переводом на новую строку, пользовательский ввод начинается с новой строки. Логично? Ещё бы :).

А если будет `input('\nВведите текст:\n')`? Давайте пробовать

```py
>>> input('\nВведите текст:\n')

Введите текст:
привет
'привет'
>>>
```

Строка приглашение началась с перевода курсора на новую строку. Поэтому первая строка вывода &mdash; пустая. Далее идет идет текст `Введите текст:`, далее курсор снова переводится на новую строку и на этом строка-приглашение заканчивается.

Отсюда вывод: понимая то, что именно делает символ `\n`, вы можете осознанно разместить его в любой части текста.

## Использование пустой строки в функции `input`, отличие строки `''` от строки `'\n'`

О пустой строке мы начали говорить, когда разбирали дефолтный аргумент для параметра `prompt` &mdash; `prompt=''`.

Пустая строка &mdash; это строковый объект без текста. Когда мы выводим в терминал пустую строку курсор остается на том же месте, где и был.

Давайте попробуем

```py
>>> print('')

>>>
```

Стоп, скажете вы, курсор перешел на новую строку, только она не заполнена.

Да, но это ничего не опровергает. Вспоминаем: дефолтное окончание работы функции `print` &mdash; перевод курсора на новую строку (`end='\n'`).

Поэтому `print('')` то же самое, что `print('', end='\n')`, а значит:
- функция `print` отобразила пустую строку, т.е. буквально "ничего", курсор остался на том же месте, что и был
- функция `print` завершила свою работу переводом курсора на новую строку, т.е. проставив неотображемый символ `\n` из параметра `end`.

Чтобы нам не мешал дефолтный аргумент для `end`, давайте его заменим на пустую строку, благодаря чему после окончания работы функции `print` курсор двигаться никуда не будет.

```py
>>> print('', end='')
>>>
```

Как видите, между приглашениями интерпретатора (`>>>`) никакого пространства нет, потому что между ними *пусто*.

Строка `'\n'` &mdash; это строка из 1-го символа, символа новой строки. Этот символ не виден нам при отображении, но он "работает", переводя курсор на новую строку.

Если вся строка представлена одним лишь этим символом (или этот символ расположен первым), то визуально мы видим *незаполненную* строку, строку без символов.

Пример

```py
>>> print('\n', end='')

>>>
```

Я специально отключил дефолтный перевод на новую строку (`end=''`), иначе мы бы получили не 1, а 2 пустых строки подряд (одна из-за переданного на вывод `\n`, вторая из-за `end='\n`).

```py
>>> print('\n')


>>>
```

В свою очередь, пустая строка (`''`) &mdash; это, простите за слог, **не** незаполненная строка (т.к. незаполненную строку возможно визуализировать и отличить от других строк), а строка с 0 символов, в ней вообще нет никаких символов, ни печатаемых, ни непечатаемых.

Ещё раз:
- `''` &mdash; пустая строка, 0 символов, не отображается никак
- `'\n'` &mdash; строка из 1 символа &mdash; непечатаемого символа "новая строка", переводит курсор на новую строку, отображаясь в виде *незаполненной* строки.

Именно поэтому, дефолтный `prompt=''` функции `input` означает, что курсор для пользовательского ввода по умолчанию находится сразу же в начале строки, т.к. текст приглашения (текст `prompt`) пустой, в нем нет ни одного символа, курсор остается на месте.

Помимо `prompt` пустая строка используется в функции `input` ещё в одном случае.

Если пользователь ничего не ввел, а лишь нажал Enter, т.е. завершил ввод, то функция `input` **возвращает объект пустой строки**.

**Запоминаем**:
- пустая строка &mdash; это строка нулевой длины, при ее отображении курсор остается на том же месте, где и был в момент предыдущего вывода информации в терминал
- пустую строку нужно отличать от незаполненной строки (`'\n'`). Незаполненная строка состоит из 1-го символа "новая строка", этот символ не отображается, но переводит курсор на новую строку, визуально оставляя за собой "пустую" строку, но правильнее говорить "незаполненная строка", чтобы отличить ее от по-настоящему пустой
- пользователь ввел текст и нажал Enter &mdash; функция `input` вернула введенный текст
- пользователь ничего не ввел и нажал Enter &mdash; функция `input` всегда возвращает строку `''`.

## Дальнейшее использование в коде текста, который ввел пользователь

Функция `input` *возвращает* то, что ввел пользователь (или пустую строку, если не ввел ничего).

Возвращенный функцией объект, разумеется, можно и нужно дальше использовать в коде (в этом и смысл функции `input` &mdash; она приемник данных от пользователя для дальнейшего использования этих данных в программе).

Как и объекты, созданные путем вызова класса, объекты, которые были созданы внутри функции и ею возвращены, нужно проименовать.

Мы уже знаем, как давать имя объекту, &mdash; через объявление переменной и присвоение ее имени какому-либо объекту.

Вспомним базовый синтаксис

```py
имя_переменной = объект
```

или

```py
имя_переменной = выражение
```

Под объектом понимается как объект непосредственно, так и объект, создаваемый в результате какого-либо выражения.

- `num = 4` &mdash; мы наделили непосредственно объект числа 4 именем переменной `num`
- `num = 2 + 2` &mdash; мы наделили объект числа 4 не непосредственно, а получив его в результате выражения `2 + 2`.

Вызов функции, как мы помним, это один из видов выражений.

Так же как под `2 + 2` мы подразумеваем `4`, также под вызовом функции `input` мы подразумеваем строковой объект, значением которого будет введенный пользователем текст, который вернет функция.

Соответственно, мы можем присвоить этому объекту имя так:

```py
some_name = input()
```

Теперь переменная `some_name` будет указывать на объект, который вернет вызов функции `input`.

Пробуем в интерпретаторе

```py
>>> age = input()
36
>>> age
'36'
>>>
```

Разберем сначала строки

```
>>> age = input()
36
```

1. Мы объявили переменную `age`, судя по ее имени, она будет указывать на что-то, связанное с возврастом.
2. Переменной `age` мы присваиваем `=` объект, который вернет вызов функции `input` &mdash; `input()`
3. После вызова интерпретатор останавливается в ожидании пользовательского ввода. Поскольку для параметра `prompt` ничего не передано, то никакой отдельной строки-приглашения не отображается.
4. Пользователь ввел символы `36`
5. Из этих символов создается строковый объект `'36'`, который возвращается как результат вызова функции `input`.
6. Возвращенному строковому объекту присваивается имя `age`.

Теперь вот эта часть

```py
>>> age
'36'
```

Мы ввели имя `age` и интерпретатор "узнал" его. В ответ он отобразил строковый объект `'36'`, как объект, находящийся в памяти под именем `age`.

Давайте дополним пример непустой строкой-приглашением, чтобы пользователь явно понимал, что от него хотят. При этом приглашение оформим так, чтобы пользователь вводил свой ответ под приглашением, а не рядом с ним.

```py
>>> age = input('Введите Ваш возраст:\n')       
Введите Ваш возраст:
36
>>> age
'36'
```

## Заключение

Основные тезисы:

1. Функция `input` предназначена для приема текста, который вводит в терминале пользователь, и далее возвращает этот текст в виде строкового объекта (объекта класса `str`) для дальнейшего использования в программе.

2. У функции `input` один параметр &mdash; `prompt`. Его дефолтное значение &mdash; *пустая строка*. Параметр отвечает за строку-приглашение, которая будет отображаться перед пользовательским вводом (разъяснение пользователю, что именно ждут от него на ввод).

3. Функция `input` возвращает строковой объект с текстом, который ввел пользователь. Если он ничего не ввел, функция возвращает объект *пустой* строки, т.е. строки нулевой длины.

4. Пустую строку (`''`) не следует путать с символом новой строки (`'\n'`). Символ новой строки &mdash; непечатаемый символ, который переводит курсор на новую строку. Этот символ, в частности, используется в качестве дефолтного в параметре `end` функции `print`. Этот параметр отвечает за то, какой символ будет ставиться после отработки функции `print`.

5. Возвращаемый функцией `input` строковый объект можно передать присвоить переменной и дальше под именем этой переменной использовать в коде программы.

## Домашнее задание

Напишите в отдельном файле программу по следующему плану:
1. Попросить пользователя ввести имя
2. Полученные данные присвоить переменной (имя переменной придумайте сами, главное, чтобы оно отражало суть переданной информации)
3. Попросить пользователя ввести фамилию
4. Полученные данные присвоить другой переменной
5. Вывести в терминал сообщение в формате

```
Добрый день, <имя> <фамилия>!
```

**Обращаю внимание**: количество пунктов плана (5) не отражает число строк кода в вашей программе (пишу на всякий случай, чтобы не было ощущения, что программа должна состоять именно из 5 строк кода).
