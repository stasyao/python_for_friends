# Урок 2. Переменные. Оператор присваивания

В этом уроке мы продолжим работать в интерпретаторе в интерактивном режиме, поэтому запустите его, 
если уже закрыли.

Результат прошлого урока &mdash; полное понимание, как создается и как работает выражение `2 + 2`.

```py
>>> 2 + 2
4   
>>> 
```

## У экземпляров класса имен нет

В дополнение к первому уроку скажу, что всё, с чем мы работаем в коде, занимает часть оперативной 
памяти на время выполнения программы. Под объект *выделяется память*.

Когда мы выполнили выражение `2 + 2` и получили `4`, объект этого числа хранится в памяти, а значит, мы к нему можем *обратиться* в последующих частях нашего кода и использовать этот объект.

Но как обратиться к созданному объекту за пределами строки кода, в которой этот объект был создан, чтобы интерпретатор нас понял?

В 1-м уроке, говоря о классах, мы выяснили, что у них есть *имена*. Эти имена существуют изначально и доступны на всем протяжении работы программы.

У объектов (экземпляров, инстансов) классов **имен нет**. Вот у класса целых чисел есть имя &mdash; `int`, а вот у объекта этого класса, например, у числа 2 имени нет.

Поэкспериментируем. Выдвинем гипотезу, что интерпретатор нас поймет, что под именем `two` скрывается объект класса `int` со значением 2. Мы помним, что имя отличается от текста (объекта класса `str`) отсутствием окружающих кавычек-"лапок".

```py
>>> two
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'two' is not defined
>>>
```

Мы получили уже знакомую по прошлому уроку ошибку `NameError`. Интерпретатор говорит нам: "Имя 'two' не определено". Иными словами, он не знает, что скрывается за этим именем.

**Запоминаем**: у каждого класса есть имя, у объекта класса при создании имени **нет**.

## Имя переменной &mdash; имя, которое мы придумываем созданному экземпляру класса

Чтобы объекту класса (тому же числу 2, к примеру) *присвоить имя* существуют *переменные* (variable). Переменная &mdash; это ссылка на объект.

Имя переменной &mdash; это "ярлычок", "лейбл", которым мы помечаем объект, чтобы позднее по этому имени обратиться к объекту.

Процесс наделения объекта класса именем через переменную включает в себя 2 шага:
- нужно *объявить переменную* &mdash; просто-напросто придумать и написать ее имя (мы помним, что без кавычек, иначе это не имя, а объект текста)
- нужно *присвоить имя переменной* конкретному объекту. Иными словами, нужно привязать ссылку к объекту.

За присвоение отвечает *оператор присваивания* `=`. Да, в Python &mdash; это не знак равенства, а знак, символизирующий создание ссылки на объект.

Схематически это выглядит так:

```
имя_переменной = объект
```

Возьмем, к примеру, для переменной имя `two`, которое мы пытались использовать ранее и присвоим этой переменной объект числа 2. Наберите `two = 2` и нажмите Enter.

```py
>>> two = 2
>>> 
```

Обратите внимание на стилистический момент: перед оператором присваивания и после следует ставить 1 пробел. Если не поставите, ошибки не будет, но стилистически правильнее ставить.

Интерпретатор ничего не ответил, снова приглашая что-нибудь ввести. Отсутствие ответа в данном случае говорит о том, что присвоение состоялось.

Проверим. Наберите теперь имя `two` и нажмите Enter.

```py
>>> two
2
>>>
```

Ошибки `NameError` нет! А почему? Потому что интерпретатор знает это имя, это имя переменной, которая ссылается на объект числа 2. Именно это число (т.е. стоящий за переменной объект) он нам и демонстрирует.

**Запоминаем**: если мы хотим обращаться к объекту класса за пределами строки кода, в которой он был создан, нам нужно создать ссылку на него (придумать ему имя). Такой ссылкой служит переменная, имя которой присваивается объекту. Как и любое иное имя (например, имя класса), имя переменной должно быть без кавычек. Присвоение имени объекту осуществляется с помощью оператора присваивания `=`.

## Как надо и не надо называть переменные

В целом вы свободны в придумывании имен переменных, но все же есть ряд ограничений и рекомендаций.

**Как НЕ надо называть переменные**.

1. Точно не следует использовать для переменные имена, которые уже знает интерпретатор как имена встроенных классов и функций.

Вот эти "запрещенные" имена: abs, aiter, all, any, anext, ascii, bin, bool, breakpoint, breakpoint, bytearray, bytes, callable, chr, classmethod, compile, complex, copyright, credits, delattr, dict, dir, divmod, enumerate, eval, exec, exit, filter, float, format, frozenset, getattr, globals, hasattr, hash, help, hex, id, input, int, isinstance, issubclass, iter, len, license, list, locals, map, max, memoryview, min, next, object, oct, open, ord, pow, print, property, quit, range, repr, reversed, round, set, setattr, slice, sorted, staticmethod, str, sum, super, tuple, type, vars, zip.

Не переживайте из-за обилия имен в списке. В начале обучения периодически сверяйтесь с ним, а дальше постепенно он "запишется на подкорку", тем более многие из перечисленных классов и функций мы будем применять на практике.

Не используйте для переменных имена классов и функций, которые вы сами будете создавать в коде.

Поясню на примере, с чем связан запрет.

Есть, например, встроенная функция с именем `print`. Ее задача &mdash; отобразить текстовое представление одного или нескольких объектов.

Наберите в интерпретаторе `print(2, 10, 'котик')`, нажмите Enter и вы получите результат работы функции &mdash; отображение в виде текста трех объектов, которые мы этой функции передали.

```py
>>> print(2, 10, 'котик')
2 10 котик
>>>
```

А теперь, допустим, вы по ошибке создали переменную с тем же именем, что и встроенная функция &mdash; переменную с именем `print`. Привязали эту переменную к какому-то объекту, например числу 5. Пробуем.

```py
>>> print = 5
>>> 
```

Интерпретатор не выдал ошибку, т.к. синтаксически имя объявленной переменной верно.

Но теперь, и это ужасно, под именем `print` интерпретатор теперь "знает" не встроенную функцию, которую мы запускали выше, а объект числа 5!

Попробуйте теперь воспользоваться функцией `print` запустив в интерпретаторе `print(2, 10, 'котик')`.

```py
>>> print(2, 10, 'котик')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'int' object is not callable
```

Если очень вольно перевести суть ошибки, она означает "число 5 нельзя вызвать, это не функция". Таким образом, c `print` интерпретатор теперь обращается не как с встроенной функцией, а как с обыкновенным числом.

**Запоминаем**: при придумывании собственных имен нужно держать в голове, что помимо имен, которые вы используете в своем коде, есть ещё набор встроенных имен. Все имена должны быть уникальны. Если присвоить объекту имя класса или имя функции, то при дальнейшем использовании этих имен они будут ввести уже к этому объекту, а не к соответствующему классу или функции.

Давайте "восстановим в правах" встроенную функцию `print` для этого с помощью ключевого слова `del` "убьем" ссылку на число 5.

```py
>>> del print
```

Теперь попробуйте снова вызвать функцию `print` и убедитесь, что она работает, т.к. переменной с именем `print` больше не существует.

```py
>>> print(2, 10, 'котик')
2 10 котик
>>>
```

2. Не используйте в именах пробелы, знаки препинания, скобки, операторы. Можно нижнее подчеркивание (`_`). Можно числа, но не первым символом.

Нарушите эти правила &mdash; получите самые разные ошибки. Повторите за мной и введите в терминал разные некорректные имена переменных.

```py
>>> 1somename = 2
  File "<stdin>", line 1
    1somename = 2
     ^
SyntaxError: invalid syntax
>>> some name = 2
  File "<stdin>", line 1
    some name = 2
         ^
SyntaxError: invalid syntax
>>> some-name = 2
  File "<stdin>", line 1
    some-name = 2
    ^
SyntaxError: cannot assign to operator
>>> some+name = 2
  File "<stdin>", line 1
    some+name = 2
    ^
SyntaxError: cannot assign to operator
>>> some,name = 2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: cannot unpack non-iterable int object    
>>> some.name = 2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'some' is not defined
>>>
```

3. Ещё раз повторюсь &mdash; имена переменных не должны быть в кавычках. В кавычках &mdash; объекты строк (текста), без кавычек &mdash; имена переменных, классов, функций.

**Как надо называть переменные**

1. Пишите на латинице маленькими буквами
2. Если имя составное, его части связывайте нижним подчеркиванием, например, `some_name`
3. Если это реализуемо, по имени переменной должно быть примерно понятно, что за объект за ней стоит, *о чём он*. Для этого переменные должны состоять из одного или нескольких английских слов, отражающих суть того, что стоит за переменной. Придумывание переменным имен ("нэйминг") &mdash; это отдельное искусство, которое постигается со временем.

Закрепим: объявим переменную `result`, которой присвоим значения выражения `2 + 2`. Проверим, на что ссылается переменная, обратившись к ней по имени.

```py
>>> result = 2 + 2
>>> result
4
```

**Запоминаем**: имена переменных не должны дублировать имена встроенных или созданных классов и функций, чтобы не парализовать их работу. Имена следует писать на латинице маленькими буквами. По возможности имена должны отражать суть того, что за ними скрывается.

## Присвоение переменной &mdash; это `statement` (инструкция)

В первом уроке мы познакомились с `expression` &mdash; типом синтаксических конструкций, которые описывают создание какого-то объекта. Примеры `expression`:
- `2` &mdash; создали объект числа 2
- `2 + 2` &mdash; путем вызова метода `__add__` (через оператор `+`) создали новый объект числа 4.

Так вот вторым основным типом синтаксических конструкций являются `statement` (инструкции).

Как и у `expression`, у `statement` есть разные типы, каждый из которых мы будем разбирать в конкретном уроке. Сейчас мы разобрали такой тип `statement` как "инструкция присваивания" (assignment statement).

Поэтому технически `result = 2 + 2` &mdash; это инструкция (statement) по присваиванию (assign) переменной с именем `result` результата вычисления выражения (expression) `2 + 2`.

**Запоминаем**: в Python-коде есть 2 основных типа синтаксических конструкций: выражения (`expression`) и инструкции (`statement`). Объявление переменной и присвоение ей какого-либо объекта &mdash; это один из видов инструкций.

## Использование объектов с помощью переменных

В самом начале мы говорили, что смысл использовать переменные в том, чтобы в любом месте кода иметь доступ к ранее созданным объектам классов.

Пока мы только научились *объявлять переменную* и *присваивать ей значение*.

Давайте теперь применим переменные. Вместо того, чтобы вычислять `2 + 2` в одной строке кода, мы сделаем программу из 4 строк:
1. Создадим объект левого числа и привяжем его к переменной
2. Создадим объект правого числа и тоже привяжем его к переменной
3. Суммируем значение двух объектов и полученный объект числа привяжем к третьей переменной.
4. Обратимся к третьей переменной, чтобы проверить, на какой объект она ссылается.

Напомню, мы продолжаем все операции проводить в интерпретаторе.

Вот что должно получиться

```py
>>> left_number = 2
>>> right_number = 2
>>> result = left_number + right_number
>>> result
4
```

Первые две строки в пояснении особо не нуждаются. Повторюсь, имена придумываем сами, у вас может быть любое другое.

А вот на третью строку особое внимание

```
left_number + right_number
```

Главное, что нужно уяснить: используя в различных выражениях и инструкциях переменные, мы на самом деле используем те объекты, которые стоят за этими переменными.

Иными словами, мы не складываем переменную `left_number` с переменной `right_number`, мы складываем объекты чисел, которые *скрываются* под этими именами в оперативной памяти.

Совсем не обязательно, чтобы в выражении участвовали или только что созданные объекты, или только ссылки на них в виде переменных.

Это вполне может быть и комбинация, например:

```py
>>> left_number = 2
>>> right_number = 2
>>> result = left_number + right_number + 5
>>> result
9
```

Обратите внимание: при суммировании мы использовали 3 объекта:
- объекты чисел 2 через обращение к ним по имени переменных;
- объект числа 5, непосредственно создав его во время операции.


**Запоминаем**: после присвоения объекту класса имени в виде переменной дальнейшее использование этого объекта в коде происходит **через имя переменной**. Все "умения" переменной &mdash; это не что иное, как функционал объекта, который стоит за этой переменной.

## Переприсваивание переменной

Последнее, о чем нужно сказать в этом уроке, что по ходу кода переменную с одним и тем же именем можно "перепривязать" к другому объекту. Делается это просто &mdash; нужно заново написать инструкцию присвоения, указав другой объект.

Пример всё прояснит

```
>>> left_number = 2
>>> right_number = 2
>>> result = left_number + right_number
>>> result
4
>>> result = 120
>>> result
120
>>>
```

Мы заново произвели операцию присваивания для переменной `result` и при дальнейшем исполнении кода она будет ссылаться на число 120, а не на число 4.

Частая ошибка при написании программ &mdash; изменение переменной путем повторного присвоения ей какого-то другого объекта. Возьмите на заметку.

**Запоминаем**. Одна и та же переменная в каждый момент времени ссылается на один и только один объект. Вместе с тем в любом месте кода можно заново произвести операцию присваивания и сменить "привязанный" объект. Производите "переприсваивание" только тогда, когда точно уверены, что ссылка на предыдущий объект вам больше не понадобится. Если понадобится, то для нового объекта создайте новую переменную.

## Заключение. Основные тезисы

1. У объектов классов при создании нет имен, а без имени к объекту невозможно обратиться в последующих частях программы.

2. Для решения этой задачи существуют *переменные*, которые представляют собой ссылки на ранее созданные объекты.

3. При объявлении переменной ей придумывается имя и через *оператор присваивания* (`=`) осуществляется привязка ссылки к объекту. Эта операция является одним из типов "инструкций" (statement).

4. Имена переменных можно использовать в коде, проводя с ними операции, которые доступны объектам, которые за этими переменными стоят. Фактически мы используем не переменные, а привязанные к ним объекты.

5. Переменные можно неоднократно перепривязывать к другим объектам, но делать это нужно осторожно, ясно понимая, что предыдущий объект точно больше не понадобится.
