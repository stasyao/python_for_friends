# Устанавливаем необходимый софт. Git bash

Прежде чем устанавливать `Git bash for Windows`, нужно получить общее представление, а что вообще такое `git` (гит) и `bash` (баш).

Начнём с `bash` и тут нам нужно сказать пару слов о видах операционных систем.

## Коротко о видах операционных систем (ОС)

2 вида самых распространенных ОС:
- ОС семейства Windows
- Unix(юникс)-подобные ОС:
  - Linux (Линукс)
  - MacOS (Мак-о-эс или в народе "мак ось")
  - Ios ("иос")
  - Android (Андроид)

"Юникс-подобные" означает, что несмотря на собственные уникальные черты, "мозги" этих ОС спроектированы на тех же принципах, что и "мозг" (технически говоря, ядро, `kernel`) ОС Unix, история которой уходит в 60-е годы XX века.

Наиболее используемыми среди программистов являются именно юникс-подобные системы, в частности, Линукс.

У Линукса есть различные вариации (дистрибутивы), например, `Ubuntu` ("Убунту"), `Debian` ("Дебиан") и т.д. Поэтому, когда говорят о конкретной Линукс ОС, говорят не "Линукс", а называют конкретный дистрибутив.

Популярность Линукса обоснована, в частности, тем, что это свободно распространяемая операционная система с открытым исходным кодом. Ни у кого не нужно покупать лицензию на нее, обновления дистрибутивов также являются бесплатным. Кроме того, каждый может модифицировать и настраивать систему под себя.

Работа с Линуксом &mdash; это по сути стандарт для любого программиста.

Один из отличительных признаков юникс-подобных систем в том, что один из основных принципов работы юникса &mdash; взаимодействие с пользователем через текстовый, а не графический интерфейс. В специальной программе (оболочке командной строки) на черном экране ("терминале") мы вводим разные команды, отправляем их операционной системе, и получаем результат.

Поэтому второй стандарт для любого программиста &mdash; это умение работать с компьютером через командную строку. Более того, зачастую графический интерфейс может отсутствовать в принципе. Например, когда мы подключаемся удаленно к серверу под управлением линукса, никаких "рабочих столов" и "иконок" мы не видим. Через командную строку (тот самый "черный экран") мы устанавливаем соединение и далее начинаем работать с удаенным компьютером через всю ту же командую строку.

Ниже на картинке пример того, как через командную строку на своем ноутбуку я ввел команду `sudo ssh ...`, чтобы подключиться к своему "облачному" компьютеру под управлением `Ubuntu` (дистрибутив Линукса).

При подключении я ввел пароль и после успешной авторизации я "зашел" на "облачную" машину и с ней я дальше взаимодействую всё так же через командную строку.

![image](https://user-images.githubusercontent.com/60841011/222127227-d626141d-47b4-4030-8717-5c37ab1cd7b1.png)

Далее более подробно поговорим о командной строке и сравним выполнение одной и той же операции через графический и через текстовый интерфейс.

## Командная строка &mdash; основа взаимодействия с юникс-подобными системами

У каждой ОС есть привычный нам графический интерфейс &mdash; рабочий стол, иконки файлов и папок.

Вообще понятие "интерфейс" &mdash; краеугольное в программировании и мы еще не раз с ним столкнемся в разных ситуациях.

Интерфейс &mdash; это некий посредник, через которого мы взаимодействуем с чем-то. Например, кнопки на пульте от телевизора это интерфейс, через который передаются наши команды телевизору.

Также и вся эта визуализация файлов и папок, с которыми мы взаимодействуем, кликая на них мышью, не что иное как интерфейс для отдачи конкретных команд операционной системе. Например, "открыть такую-то папку".

Помимо графического интерфейса с операционной системой можно взаимодействовать через **командную строку** (**command line**), вводя различные текстовы команды.

Командная строка, это тот самый "черный экран" с мигающим курсором, знакомый олдам, которые застали еще до-Windows времена.

Но командная строка, как я уже сказал, это лишь интерфейс, некий приемник наших команд компьютеру. Непосредственное же доведение этих команд до ядра операционной системы с последующим решением как их выполнять обеспечивает специальная программа, которая называется `shell` ("шелл").

Таким образом, **шелл** &mdash; это программа, которая посредством интерфейса командной строки принимает от пользователя текстовые команды и далее обеспечивает их выполнение, связываясь с "мозгами" операционной системы.

Окошко, в котором работает шелл, называется "окном терминала" или просто "терминалом" (**terminal window**). Поэтому, когда говорят "в терминале набираем то-то", это означает, что работаем через шелл (через командную строку), вводим какие-то команды для исполнения.

### Пример

На рабочем столе есть папка `SomeFolder`.

![image](https://user-images.githubusercontent.com/60841011/221964449-8487ec84-959d-41de-b6e0-e18d5f1ab111.png)

Мы наблюдаем эту папку (точнее ее визуализацию в виде иконки с надписью `SomeFolder`) и знаем, что она находится именно на "рабочем столе", благодаря графическому интерфейсу нашей операционной системы. Такое вот наглядное представление.

Далее мы кликаем мышью по этой папке. В операционную систему уходят команды "открыть такую-то папку" и "показать ее содержимое".

Снова через графический интерфейс в открывшемся окне мы наблюдаем результат выполнения команды.

![image](https://user-images.githubusercontent.com/60841011/221967196-2a387040-d0d2-40cc-9f82-9de1f6ccba01.png)

Видим, что внутри папки 2 файла:
- `file1.txt`
- `file2.txt`

**Теперь давайте направим те же команды нашей операционной системе, но только через шелл**.

Напомню, shell предоставляет нам в качестве интерфейса для "общения" с операционной системой командную строку, которая ожидает от нас текстовых команд.

Вот как это может выглядеть

![image](https://user-images.githubusercontent.com/60841011/221968153-6ad0494c-24a4-42c9-8e5b-ee3f5d86b276.png)

Зеленым имя пользователя, который сейчас работает в ОС (`stasyao`), а после знака `@` имя компьютера, котором запущена ОС.

Тут может возникнуть вопрос: пользователя мы идентифицировали, компьютер, за которым он работает тоже, но в каком конкретно месте в файловой системе нашей операционной системы мы сейчас находимся?

С графическом интерфейсом понятно - после того как мы включили компьютер, нам отображается "рабочий стол", что в категориях файловой системы означает "мы находимся в папке (синоним - директория) под названием Desktop на диске C". Иными словами, мы начинаем общение через графический интерфейс, находясь в определенной точке, в определенной директории.

Разумеется, то же самое применимо и командной строке. Когда мы вместо графического интерфейса начинаем общение с операционной системой через шелл, мы тоже находимся в некоей отправной точке, некоей директории.

Так вот эта самая начальная директория обозначается знаком `~` (тильда), который мы видим на картинке. Т.е. тильда это просто условный знак, за которым скрывается строка с полным адресом начальной ("домашней") директории текущего пользователя.

В моем примере за `~` скрывается директория с полным адресом `/home/stasyao`, а нам нужна директория `SomeFile` в директории рабочего стола. Полный адрес ее такой `/mnt/c/Desktop/SomeFolder`

Наконец, последний элемент &mdash; знак доллара `$`. Он символизирует, что командная строка готова принять команду от пользователя. Иными словами, это "приглашение ввести команду". Команда вводится сразу после этого знака.

Таким образом, `stasyao@DESKTOP-KVJG5JB:~$` можно расшифровать так:

> "Пользователь `stasyao` на компьютере `DESKTOP-KVJG5JB`, ты сейчас находишься в своей домашней директории (`~`), и можешь вводить команду для исполнения операционной системой".

Не обращайте сейчас внимание на сами адреса и их структуру, сейчас мы просто смотрим на то, как сделать то же, что мы сделали через графический интерфейс (открыть папку `SomeFolder` на рабочем столе и посмотреть ее содержимое), с помощью комадной строки.

А делать это мы будем через последовательную отдачу текстовых команд:
- перейти в директорию `SomeFolder` (= "открыть эту директорию")
- показать содержимое этой директории

Первое действие выполняется с помощью команды `cd` (сокращение от `change directory`, "сменить директорию"). Мы вводим команду и через пробел указываем путь к искомой директории

![image](https://user-images.githubusercontent.com/60841011/221975717-c973c5b8-8572-47ad-a04e-df41ebfb5b86.png)

Что произошло после ввода команды и нажатия `Enter`:
- появилась новая строка с приглашением ввести команду
- в этой новой строке вместо `~` мы видим адрес той директории, какую указали ранее при отдаче команды `cd`
- а значит, всё сработало &mdash; мы сменили свое местоположение в файловой системе на папку `SomeFolder` = мы "открыли" её.

Теперь нам нужно посмотреть содержимое этой папки. Для этого мы вводим новую команду &mdash; команду `ls`.

![image](https://user-images.githubusercontent.com/60841011/221976732-67193a15-8d97-41d2-bd7c-a0d9c4bae2aa.png)

Мы видим на следующей строке результат выполнения команды: названия двух файлов (`file1.txt`, `file2.txt`). Вот мы и посмотрели содержимое директории `SomeFolder`.

Ниже мы видим приглашение ввести следующую команду (знак доллара).

## Bash &mdash; одна из самых распространенных оболочек командной строки

Вот теперь мы, наконец, подбираемся к тому, а что же такое "баш" (`bash`). Это не что иное, как один из видов оболочки ("шелл", shell) командной строки. Т.е. шелл &mdash; это родовое понятие класса программ, которые дают нам интерфейс в виде командной строки, принимают через эту строку команды и обеспечивают их исполнение, связываясь с ядром операционной системы. А `bash` &mdash; это конкретная реализация подобной программы, очень популярная в Линукс-системах.

Есть и другие виды `shell`. Например, в последних версиях `MacOS` дефолтной (по умолчанию) оболочкой командной сроки (или, иными словами, дефолтным шелл) является программа подназыванием `zsh` ("зед шелл").

Вот скрин из MacOS

![image](https://user-images.githubusercontent.com/60841011/222063912-c7b584d4-087c-41e4-aebb-207e7d7fda45.png)

Обратите внимание на строку "The default interactive shell is now zsh" ("Сейчас дефолтная интерактивная шелл &mdash; zsh").

Базовые команды для общения с операционной системы во всех видах шелл, как правило, одни и те же. Что, к примеру, через `bash` вы введете команду `ls`, что эту же команду через `zsh`, результат будет один &mdash; отобразится содержимое текущей директории.

"bash for Windows" можно рассматривать как оболочку командной строки, которую вы будете запускать под Windows, но работать с ней так, словно вы работаете с Линуксом, использовать те же команды. Такой вот эмулятор Линукс-шелла, работающего в среде Windows.

Плюс работы через юникс-подобный шелл, а не через командную строку самого Windows (cmd, PowerShell), в том, что постепенно вы учитесь работать с Линуксом и когда настанет время (а оно настанет) пересесть на "чистый" Линукс дискомфорта не будет. Плюс, как я уже говорил, работа с Линуксом &mdash; это по сути стандарт для любого программиста, так что чем раньше начнем его осваивать, тем лучше.

### Summary o `bash`

- стандартными операционными системами для программистов являются Unix-подобные системы, прежде всего, Linux, которая представлена разными дистрибутивами (Ubuntu, Debian и т.д.)
- с операционной системой (как с Windows, так и с Linux) можно взаимодействовать 2 способами: через графический интерфейс и через текстовый интерфейс (командную строку)
- стандартный путь взаимодействия программиста с операционной системой &mdash; командная строка
  - во-первых, запуск написанных программ, как правило, осуществляется через командную строку
  - во-вторых, на компьютере ("машине", сервере), за которым нам предстоит работать, может в принципе отсутствовать графический интерфейс
- командная строка &mdash; это интерфейс, приемник наших команд, которые мы вводим с клавиатуры. Дальнейшее исполнение этих команд обеспечивает специальный класс программ, который именуется шелл (shell). По сути, через командную строку мы работаем с шеллом (оболочкой командной строки). Шелл принимает через командную строку инструкции и дальше связывается с ядром операционной системы для выполнения этих инструкций
- одной из наболее распространенных shell-программ для Линукс является bash ("баш"). Многие другие shell-программы в юникс-подобных системах (например, в MacOS) имеют помимо собственного, тот же набор команд, что и баш
- Git bash for Windows позволяет запускать подобную bash программу для взаимодействия с операционной системой Windows. Иными словами работаем под Windows, но как будто бы общаемся с Линуксом :)

## C `bash` разобрались, что же такое `git`?

Здесь будет точно коротко :) `git` (гит) &mdash; это ещё один из столпов в работе любого программиста.

Гит &mdash; это программа, которая реализует систему контроля версий. Представьте, что у вас есть папка с файлами. 10, 100, 1000 файлов, не важно. Вы каждый день с ними работаете, что-то вносите, что-то меняете, что-то удаляете (как текст внутри файла, так и сам файл). И вот теперь представьте, что у вас есть возможность спустя неделю-месяц-год посмотреть, а в каком виде была вся ваша папка на любой момент времени? Вот это и есть гит. Гит, как фотограф, делает "снимок" состояния, в котором находятся все файлы в папке на определенный момент времени.

Например, мы можем внести хоть 100 правок в текст, а потом с помощью гит "откатиться" к первоначальной версии текста, или, например, к версии, которая была после внесения 51-й правки, или 49-й.

Кстати, замечательный факт: разработчик Линукса и Гита, двух общемировых программных технологий, один и тот же человек &mdash; Линус Торвальдс.

**Итог**. Устанавливая Git bash for Windows мы убиваем двух зайцев:
- устанавливаем себе гит (с которым пока мы работать не будем)
- устанавливаем себе оболочку bash, через которую можно работать как с гитом, так и с другими программами (прежде всего, с программами на Python, которые мы будем писать), привыкая работать "как бы в Линуксе".

## А теперь собственно установка Git bash for Windows

Заходим на сайт https://gitforwindows.org/ и нажимаем Downnload.

![image](https://user-images.githubusercontent.com/60841011/222139856-96f50c39-5c79-442d-90c0-be245058e3c6.png)

Запускаем скачанный `exe`-файл.

![image](https://user-images.githubusercontent.com/60841011/222140178-efffdfaa-34f6-4117-b0bf-d84cef760e2f.png)

Нажимам Next

![image](https://user-images.githubusercontent.com/60841011/222140286-a2116ce4-4e4a-4a63-9a41-70442ad2a855.png)

Снова Next (думаю, дефолтную папку переопределять нет смысла)

![image](https://user-images.githubusercontent.com/60841011/222147689-9e05a2cd-d60f-444b-92eb-895d62172c30.png)

Не меняем ничего. Next

![image](https://user-images.githubusercontent.com/60841011/222148021-0982877f-11ce-48ee-9e3e-5b590b193d8c.png)

Не меняем ничего. Next

![image](https://user-images.githubusercontent.com/60841011/222148270-bde897b8-81d7-4743-a785-cd9ec86e0f9e.png)

Выбираем в выпадающем списке "Use Nano editor by default". Next

![image](https://user-images.githubusercontent.com/60841011/222148527-420882ac-7ddc-4a8f-a7d2-558b19fe27fe.png)

Ничего не меняем. Next

![image](https://user-images.githubusercontent.com/60841011/222148773-b7eaa134-19a8-45c1-8588-af34a830d217.png)

Ничего не меняем. Next

![image](https://user-images.githubusercontent.com/60841011/222148872-553d092e-1a50-4738-849a-0cdf00c73d08.png)

Ничего не меняем. Next

![image](https://user-images.githubusercontent.com/60841011/222149007-139d8b5b-f9b1-44c4-91bf-161e5ee31d45.png)

Ничего не меняем. Next

![image](https://user-images.githubusercontent.com/60841011/222149146-1fcd319e-dff6-46ab-931f-95878954af1c.png)

Ничего не меняем. Next

![image](https://user-images.githubusercontent.com/60841011/222149282-f0360435-06dd-4434-8a31-f9567a959dd4.png)

Ничего не меняем. Next

![image](https://user-images.githubusercontent.com/60841011/222149425-631f4e15-7dc4-4b53-ab00-abf2bde3bcc2.png)

Ничего не меняем. Next

![image](https://user-images.githubusercontent.com/60841011/222149536-06345e8c-73e0-470e-8ed5-b49f9472ec23.png)

Ничего не меняем. Next

![image](https://user-images.githubusercontent.com/60841011/222149649-bf125c3d-ac1e-4aa4-88c4-5da456f941f9.png)

Ничего не меняем. Next

![image](https://user-images.githubusercontent.com/60841011/222149870-aaf812d1-c1e9-422b-8946-d51c8b99d292.png)

Ничего не меняем. **Install**
